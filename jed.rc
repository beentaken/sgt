% -*- mode: slang; mode: fold -*-
% Simon Tatham: version $Revision: 1.30 $

%{{{ load Emacs keybindings to start with

if (BATCH == 0) {
    () = evalfile("emacs");            % Emacs-like bindings
}

%}}}
%{{{ Real Systems(tm) use ^? as delete, so ^H is help

setkey("help_prefix", "^H");

%}}}
%{{{ force instant syntax-highlighting update

% Force full screen update on insert/delete keys.
% Unpleasant, but seems to work: "dummy" seems to be the best way I can
% find to do nothing and trigger screen updating...
define dummy() {
    insert(".");
    deln(left(1));
}
define jedrc_self_insert() {
    dummy();
    call("self_insert_cmd");
}
for ($1 = 33; $1 < 127; $1++) {
    setkey(".dummy \"self_insert_cmd\" call", char($1));
}
setkey (".1 deln", "^D");
setkey(".\"backward_delete_char_untabify\" call dummy", "^?");

%}}}
%{{{ In read-only buffers, Space, B, G, g, 0 and Z start to page around
define quick_killbuf() {
    delbuf(whatbuf());
}

define jedrc_ro_internal_alternate(command, char) {
    variable flags;
    (,,,flags) = getbuf_info();
    if (flags & 8)
        call(command);
    else
        jedrc_self_insert();
}

define jedrc_ro_slang_alternate(command, char) {
    variable flags;
    (,,,flags) = getbuf_info();
    if (flags & 8)
        @command();
    else
        jedrc_self_insert();
}

setkey (".\"page_down\" \" \" jedrc_ro_internal_alternate", " ");
setkey (".\"page_up\" \"b\" jedrc_ro_internal_alternate", "b");
setkey (".\"page_up\" \"B\" jedrc_ro_internal_alternate", "B");
setkey (".\"beg_of_buffer\" \"g\" jedrc_ro_internal_alternate", "g");
setkey (".\"beg_of_buffer\" \"0\" jedrc_ro_internal_alternate", "0");
setkey (".\"end_of_buffer\" \"G\" jedrc_ro_internal_alternate", "G");
setkey (".\"end_of_buffer\" \"z\" jedrc_ro_internal_alternate", "z");
setkey (".\"end_of_buffer\" \"Z\" jedrc_ro_internal_alternate", "Z");
setkey ("jedrc_ro_slang_alternate(&quick_killbuf,\"q\")", "q");
setkey ("jedrc_ro_slang_alternate(&quick_killbuf,\"Q\")", "Q");
setkey ("jedrc_ro_slang_alternate(&search_forward,\"/\")", "/");
setkey ("jedrc_ro_slang_alternate(&search_backward,\"?\")", "?");

% We have to do this to override slang_mode's underhand funtation of
% the C mode keymap
define slang_mode_hook() {
    local_setkey(".\"page_down\" \" \" jedrc_ro_internal_alternate", " ");
}

%}}}
%{{{ ^X^D to insert the date; ^X4^D/^X4d to insert eight-digit dates

% insert date
define insert_date() {
    variable t = time;
    insert(sprintf("%s-%s-%s", substr(t,9,2),
                   substr(t,5,3), substr(t,21,4)));
}
setkey("insert_date", "^X^D");

% insert 8-digit date
define insert_8dig_date(s) {
    variable t = time;
    variable y, m, nm, d;
    d = substr(t,9,2);
    if (substr(d,1,1) == " ")
        d = "0" + substr(d,2,1);
    m = substr(t,5,3);
    nm = (is_substr("----Jan-Feb-Mar-Apr-May-Jun-Jul-Aug-Sep-Oct-Nov-Dec-", m)
          / 4);
    y = substr(t,21,4);
    insert(sprintf("%s%s%02d%s%s", y, s, nm, s, d));
}
setkey("insert_date", "^X^D");
setkey(". \"-\" insert_8dig_date", "^X4^D");
setkey(". \"\" insert_8dig_date", "^X4d");
setkey(". \"\" insert_8dig_date", "^X4D");

%}}}
%{{{ Extra bindings: ^X^I to toggle insert mode, ^Xg to go to line
setkey("toggle_overwrite", "^X^I");
setkey("goto_line_cmd", "^Xg");
%}}}
%{{{ turn off the menu bar

% disable top menu bar
enable_top_status_line (0);

#ifdef MSWINDOWS
#ifexists destroy_menubar
destroy_menubar();
#endif
#ifexists w32_destroy_menubar
w32_destroy_menubar();
#endif
#endif

%}}}
%{{{ file functions: ^X^R, M-x cd, M-x revert, M-x insh

define find_file_read_only() {
    variable file;
    file = read_file_from_mini ("Find file read-only:");
    !if (strlen (extract_filename(file))) return;

    find_file (file);
    pop();
    set_readonly(1);
}

define set_buffer_dir (dir) {
    variable buf, flags;
    (, buf, flags) = getbuf_info();
    setbuf_info (dir, buf, flags);
}

define cd() {
    variable dir;
    dir = read_file_from_mini ("Change buffer directory to:");
    if (file_status(dir) != 2) {
        error("Expecting directory name.");
        return;
    }
    set_buffer_dir (dir);
}

define revert() {
    variable file, dir, line, col;

    (file,dir,,) = getbuf_info();
    file = dircat(dir,file);

    line = what_line(); col = what_column();
    delbuf (whatbuf());
    !if (find_file (file)) message ("File has disappeared! New file.");
    goto_line(line); goto_column(col);
}

define insh() {
    variable cmd;
    cmd = read_mini ("$", "", "");
    if (strlen(cmd) > 0) {
	run_shell_cmd (cmd);
    }
}

setkey("find_file_read_only", "^X^R");

%}}}
%{{{ F7 to execute macro

#ifdef MSDOS MSWINDOWS
setkey("execute_macro", "^@A");
#else
setkey("execute_macro", "^[[18~");
#endif

%}}}
%{{{ bookmark functions: F3 to insert bookmark, F4 to go to it
variable bookmark_str = "\176\174\176";
define set_bookmark() {
    insert(bookmark_str);
}
define goto_bookmark() {
    push_spot();
    bob();
    if (fsearch(bookmark_str)) {
        pop_spot();
        bob();
        () = fsearch(bookmark_str);
        deln(strlen(bookmark_str));
        message("Found and removed bookmark.");
    } else {
        pop_spot();
        error("No bookmark found.");
    }
}
#ifdef MSDOS MSWINDOWS
setkey("set_bookmark", "^@=");
setkey("goto_bookmark", "^@>");
#else
setkey("set_bookmark", "^[[13~");
setkey("goto_bookmark", "^[[14~");
setkey("set_bookmark", "^[OR");
setkey("goto_bookmark", "^[OS");
setkey("set_bookmark", "^[[[C");
setkey("goto_bookmark", "^[[[D");
#endif
%}}}
%{{{ shell grep_goto function: F9

define grep_goto() {
    variable filename, line;
    push_spot();
    bol_skip_white();
    push_mark();
    skip_chars("^:\n");
    filename = bufsubstr();
    line = 1;
    if (looking_at(":")) {
        go_right_1();
        push_mark();
        skip_chars("^:\n");
        line = integer(bufsubstr());
    }
    pop_spot();
    if (find_file(filename))
        goto_line(line);
}

#ifdef MSDOS MSWINDOWS
setkey("grep_goto", "^@C");
#else
setkey("grep_goto", "^[[20~");
#endif
%}}}
%{{{ disable isearch

setkey("search_forward", "^S");
setkey("search_backward", "^R");

%}}}
%{{{ redefine bits of C mode

define insert_openbrace_cmd () %{{{
{
    insert_char ('{');
    indent_line ();
}
%}}}
define insert_shutbrace_cmd () %{{{
{
    insert_char ('}');
    indent_line ();

    call("backward_delete_char");
    call("self_insert_cmd");           % so we get the blink!
}
%}}}
define c_multiline_comment() %{{{
{
    bol();
    skip_white();
    !if (eolp()) {
        bol();
        insert_char('\n');
        go_left(1);
    }
    insert("/*\n*\n*/");
    go_up(2);
    indent_line();
    go_down(2);
    indent_line();
    go_up(1);
    indent_line();
    eol();
    insert(" ");
}
%}}}
define c_mode_hook() %{{{
{
    variable keymap;
    keymap = what_keymap();
    definekey("insert_openbrace_cmd", "{", keymap);
    definekey("insert_shutbrace_cmd", "}", keymap);
    definekey("c_multiline_comment", "^XC", keymap);
}
%}}}

%}}}
%{{{ ensure bash scripts are edited in sh mode

define bash_mode() {
    sh_mode();
}

%}}}
%{{{ ^X F is death; disable it
unsetkey("^Xf");
unsetkey("^XF");
%}}}
%{{{ global variables

#ifdef VMS UNIX
USE_ANSI_COLORS = 1;
#endif
No_Backups = 1;
Startup_With_File = 0;
DISPLAY_TIME = 1;
HIGHLIGHT = 1;
WANT_SYNTAX_HIGHLIGHT = 1;
#ifdef MSDOS
HORIZONTAL_PAN = -1;                   % pan *whole* window
LINENUMBERS = 2;                       % display line and column numbers
#else
HORIZONTAL_PAN = 20;                   % pan current line only
LINENUMBERS = 1;                       % display line numbers
#endif
BLINK = 1;                             % blink matching parenthesis
TAB_DEFAULT = 8;
WRAP = 70;                             % wrap column
ADD_NEWLINE = 0;                       % add newline to file if not present
IGNORE_BEEP = 1;                       % beep terminal during error messages
_traceback = 0;                        % don't dump traceback on S-Lang errors
WRAP_INDENTS = 0;                      % don't indent next line after wrapping
#ifndef MSDOS OS2 MSWINDOWS
OUTPUT_RATE    = 0;
#endif
Fold_Mode_Ok = 1;

% C-mode variables
C_INDENT        = 4;                   % indent within block
C_BRACE         = 0;                   % indent for brace
C_BRA_NEWLINE   = 0;                   % don't insert a newline before '{'
C_Colon_Offset  = 2;                   % indent case statements by two
C_CONTINUED_OFFSET = 4;                % indent for unbraced then-clauses
C_Preprocess_Indent = 0;               % indent for nested #if/#endifs

#ifdef UNIX
variable UCB_Mailer; UCB_Mailer = "/usr/ucb/mail";
#endif

#ifdef MSDOS XWINDOWS
ALT_CHAR = 27;                         % the Meta- or Alt-key prefix
#endif

META_CHAR       = -1;   % All chars with hi bit set will self insert

#ifdef MSDOS OS2
DISPLAY_EIGHT_BIT = 1;
#else
DISPLAY_EIGHT_BIT = 160; % Other systems assume ISO Latin 1
#endif

%}}}
%{{{ colours

#ifdef XWINDOWS %{{{
set_color("normal", "#cccccc", "#000000");
set_color("status", "#ffff55", "#0000bb");
set_color("region", "#000000", "#bbbbbb");
set_color("operator", "#ffffff", "#000000");   % +, -, etc..
set_color("number", "#5555ff", "#000000");     % 10, 2.71, etc..
set_color("comment", "#bbbb00", "#000000");    % /* comment */
set_color("string", "#00bb00", "#000000");     % "string" or 'char'
set_color("keyword", "#ff5555", "#000000");    % if, while, unsigned, ...
set_color("keyword1", "#55ff55", "#000000");   % exit, NULL, strcpy, ...
set_color("delimeter", "#ffff55", "#000000");  % {}[](),.;...
set_color("preprocess", "#00bbbb", "#000000"); % #ifdef ....
set_color("menu", "#ffffff", "#0000bb");       % menu bar
set_color("message", "#cccccc", "#000000");    % colour for messages
set_color("error", "#ffff55", "#bb0000");      % colour for errors
set_color("dollar", "#bb0000", "#000000");     % dollar sign continuation
set_color("...", "#55ff55", "#000000");        % fold indicator

call("redraw");
%}}}
#else
#ifdef MSWINDOWS %{{{
set_color("normal", "204,204,204", "00,00,00");
set_color("status", "255,255,55", "00,00,187");
set_color("region", "00,00,00", "187,187,187");
set_color("operator", "255,255,255", "00,00,00");   % +, -, etc..
set_color("number", "55,55,255", "00,00,00");     % 10, 2.71, etc..
set_color("comment", "187,187,00", "00,00,00");    % /* comment */
set_color("string", "00,187,00", "00,00,00");     % "string" or 'char'
set_color("keyword", "255,55,55", "00,00,00");    % if, while, unsigned, ...
set_color("keyword1", "55,255,55", "00,00,00");   % exit, NULL, strcpy, ...
set_color("delimeter", "255,255,55", "00,00,00");  % {}[](),.;...
set_color("preprocess", "00,187,187", "00,00,00"); % #ifdef ....
set_color("menu", "255,255,255", "00,00,187");       % menu bar
set_color("message", "204,204,204", "00,00,00");    % colour for messages
set_color("error", "255,255,55", "187,00,00");      % colour for errors
set_color("dollar", "187,00,00", "00,00,00");     % dollar sign continuation
set_color("...", "55,255,55", "00,00,00");        % fold indicator

call("redraw");
%}}}
#else %{{{
set_color("normal", "lightgray", "black");
set_color("status", "yellow", "blue");
set_color("region", "black", "lightgray");
set_color("operator", "white", "black");       % +, -, etc..
set_color("number", "brightblue", "black");    % 10, 2.71, etc..
set_color("comment", "brown", "black");        % /* comment */
set_color("string", "green", "black");         % "string" or 'char'
set_color("keyword", "brightred", "black");    % if, while, unsigned, ...
set_color("keyword1", "brightgreen", "black"); % exit, NULL, strcpy, ...
set_color("delimeter", "yellow", "black");     % {}[](),.;...
set_color("preprocess", "cyan", "black");      % #ifdef ....
set_color("menu", "white", "blue");            % menu bar
set_color("message", "lightgray", "black");    % colour for messages
set_color("error", "yellow", "red");           % colour for errors
set_color("dollar", "red", "black");           % dollar sign continuation
set_color("...", "brightgreen", "black");      % fold indicator

#ifdef UNIX VMS
if (USE_ANSI_COLORS) call ("redraw");
#else
call("redraw");
#endif
%}}}
#endif
#endif

%}}}
%{{{ terminal setup for Unix

#ifdef UNIX
$1 = "vt100 vt102 vt200 dec-vt220 vt300 vt320 vt420 xterms sterm";
if (is_substr($1, getenv("TERM"))) set_term_vtxxx(0);
#endif

%}}}
%{{{ M-x i1 to i8, t1 to t8, gnu

%
% Choose C indentation
%
define i(ind) { %{{{
    variable mode;

    (, mode) = what_mode();
    if (mode & 2) {
        C_INDENT = ind;
        C_BRACE = 0;
        C_CONTINUED_OFFSET = ind;
        C_Colon_Offset = ind/2;
    }
} %}}}
define gnu() { %{{{
    variable mode;

    (, mode) = what_mode();
    if (mode & 2) {
        C_INDENT = 2;
        C_BRACE = 2;
        C_CONTINUED_OFFSET = 2;
    }
} %}}}

define i1() { i(1); }
define i2() { i(2); }
define i3() { i(3); }
define i4() { i(4); }
define i5() { i(5); }
define i6() { i(6); }
define i7() { i(7); }
define i8() { i(8); }

% Insert a "tab" of as many columns as desired. Use "real" tab characters
% iff we're at the beginning of a line
variable VAR_TAB_SIZE;
VAR_TAB_SIZE = 2;
define var_tab() { %{{{
    variable i, j;
    push_spot();
    bskip_chars (" \t");
    if (bolp()) {
        pop_spot();
        i = what_column() + VAR_TAB_SIZE - 1;
        i = i - (i mod VAR_TAB_SIZE);
        insert_char('.');
        bol();
        trim();
        whitespace(i);
        call("delete_char_cmd");
    } else {
        pop_spot();
        j = (what_column() - 1) mod VAR_TAB_SIZE;
        i = TAB;
        TAB = 0;
        whitespace (VAR_TAB_SIZE - j);
        TAB = i;
    }
} %}}}

define t(tab) { %{{{
    VAR_TAB_SIZE = tab;
    local_setkey("var_tab", "^I");
} %}}}

define t1() { t(1); }
define t2() { t(2); }
define t3() { t(3); }
define t4() { t(4); }
define t5() { t(5); }
define t6() { t(6); }
define t7() { t(7); }
define t8() { local_setkey("self_insert_cmd", "^I"); }
define t9() { t(9); }
define t10() { t(10); }

%}}}
%{{{ M-x underline and M-x underline-double

define jedrc_underline(s) {
    variable i, len;
    push_spot();
    i = what_column();
    go_up_1();
    eol();
    i = what_column() - i;
    pop_spot();
    len = strlen(s);
    while (i > 0) {
        insert(s);
        i = i - len;
    }
}

define underline() { jedrc_underline("-"); }
define underline_double() { jedrc_underline("="); }

add_completion("underline");
add_completion("underline_double");

%}}}
%{{{ ^X^] to show column

define showcolm() {
    message(Sprintf("Cursor is at column %d", what_column(), 1));
}
setkey("showcolm", "^X^]");

%}}}
%{{{ makefile_mode, or hacks thereabout

define makefile_mode() {
    sh_mode();
}

variable jedrc_old_defmode = Default_Mode;

define jedrc_default_mode() {
    variable name;
    (name,,,) = getbuf_info();
    name = extract_filename(name);
    if (
#ifdef MSDOS MSWINDOWS
	strup(name) == "MAKEFILE"
#else
	name == "Makefile" or name == "makefile"
#endif
	)
        makefile_mode();
    else
        @jedrc_old_defmode();
}

Default_Mode = &jedrc_default_mode;

%}}}
%{{{ M-x q, Q, rq/sq/qq and sig

% for e-mail and news: quote a paragraph
define q() {
    push_spot();
    EXIT_BLOCK {
        pop_spot();
    }

    bol();
    if (eolp())
        break;

    while ((what_char() != '\n') and (bobp() == 0)) {
        go_up(1);
        bol();
    }
    if (what_char() == '\n')
        go_down(1);
    bol();
    while ((what_char() != '\n') and (eobp() == 0)) {
        insert("> ");
        !if (down(1))
            break;
        bol();
    }
}

% and un-quote it again
define Q() {
    push_spot();
    EXIT_BLOCK {
        pop_spot();
    }

    bol();
    if (eolp())
        break;

    while ((what_char() != '\n') and (bobp() == 0)) {
        go_up(1);
        bol();
    }
    if (what_char() == '\n')
        go_down(1);
    bol();
    while ((what_char() != '\n') and (eobp() == 0)) {
        if (what_char() == '>')
            call("delete_char_cmd");
        if (what_char() == ' ')
            call("delete_char_cmd");
        !if (down(1))
            break;
        bol();
    }
}

% Re-cast a (multi-)quoted paragraph in Richard K's quoting style
define rq() {
    push_spot();
    EXIT_BLOCK {
        pop_spot();
    }

    bol();
    if (eolp())
        break;

    while ((what_char() != '\n') and (bobp() == 0)) {
        go_up(1);
        bol();
    }
    if (what_char() == '\n')
        go_down(1);
    bol();
    while ((what_char() != '\n') and (eobp() == 0)) {
        if (what_char() == '>') {
            while (what_char() == '>') {
                go_right_1();
                push_mark();
                skip_white();
                if (eolp() or what_char() != '>') {
                    pop_mark(1);
                    break;
                }
                del_region();
            }
            if (what_char() != ' ' and what_char() != '\t')
               insert_char(' ');
            bol();
        }
        !if (down(1))
            break;
        bol();
    }
}

% Re-cast a multilevel quoted paragraph in my attribution style
define sq() {
    variable qlevel, mlevel, ignorelevel, seen, snippet, dodown, top;
    variable realtop;

    bol();
    if (eolp())
        break;

    while ((what_char() != '\n') and (bobp() == 0)) {
        go_up(1);
        bol();
    }
    if (what_char() == '\n')
        go_down(1);
    bol();

    realtop = create_user_mark();
    EXIT_BLOCK {
        goto_user_mark(realtop);
    }

    % The effect we want is as follows: an _attribution line_ is defined
    % as a line of quoting level N (may be 0) that occurs before any lines
    % of quoting level N+1 that _aren't attributions_. (That proviso is
    % really important: it causes the whole transformation to become
    % idempotent, and makes it continue to work when it sees a mixture of
    % this attribution style and the traditional one.)

    % The algorithm we adopt is as follows: we scan down the paragraph and
    % find the maximum quoting level M. We then scan down the paragraph
    % again and take out all the lines before the first M-level line that
    % aren't (M-1) level, i.e. _aren't_ attributions. Then we proceed
    % further down until we see a non-M-level line and insert all those
    % lines we took out. This will cause the M-level lines to be preceded
    % only by their attribution at the top of the paragraph. We then
    % repeat the whole process starting from just below the M-level lines.
    %
    % Because of the possibility of interleaved text, we ignore all lines
    % of a quoting level we have already dealt with in subsequent steps.

    ignorelevel = -1;
    top = create_user_mark();
    forever {
        mlevel = 0;
        % Scan to find M.
        goto_user_mark(top);
        while ((what_char() != '\n') and (eobp() == 0)) {
            % Measure the quoting level of the line.
            qlevel = 0;
            while (what_char() == '>') {
                qlevel++;
                go_right_1();
                skip_white();
                if (eolp() or what_char() != '>') {
                    break;
                }
            }
            if ((ignorelevel < 0 or qlevel < ignorelevel) and
                mlevel < qlevel)
                mlevel = qlevel;

            !if (down(1))
                break;
            bol();
        }

        % If M == 0, we've finished.
        if (mlevel == 0)
            break;

        % Having found M, move all things above the first M line that aren't
        % level M-1 to just after the first contiguous block of M lines.
        seen = 0;
        snippet = "";
        goto_user_mark(top);
        while ((what_char() != '\n') and (eobp() == 0)) {
            % Measure the quoting level of the line.
            qlevel = 0;
            while (what_char() == '>') {
                qlevel++;
                go_right_1();
                skip_white();
                if (eolp() or what_char() != '>') {
                    break;
                }
            }
            dodown = 1;
            % If we haven't yet seen an M line...
            if (seen == 0) {
                if (qlevel == mlevel) {
                    % ... and this is one, then now we have. :-)
                    seen = 1;
                } else if (qlevel != mlevel-1) {
                    % ... but if this isn't M or M-1 then snip it.
                    bol(); push_mark(); eol(); snippet += bufsubstr() + "\n";
                    bol(); push_mark(); eol(); go_right_1(); del_region();
                    dodown = 0;
                }
            } else {
                % If we have seen an M line, then we stop if this isn't one.
                if (qlevel != mlevel) {
                    bol();
                    top = create_user_mark();
                    insert(snippet);
                    snippet = "";
                    break;
                }
            }

            if (dodown) {
                !if (down(1)) {
                    eol();
                    break;
                }
            }
            bol();
        }

        % Robustness: if we've reached end of paragraph and the snippet
        % hasn't been pasted, paste it.
        if (snippet != "") {
            !if (bolp())
                insert("\n");          % just in case EOF
            insert(snippet);
        }

        pop_spot();

        ignorelevel = mlevel;
    }
}

% do all quoting things
define qq() {
    rq();
    sq();
}

% the core routine to actually insert the sig text
define jedrc_insert_sigtext() {
    variable f = expand_filename("~/.sigs/Makesig");
    if (1 == file_status(f))
        run_shell_cmd("perl " + f);
    else
        () = insert_file(expand_filename("~/.signature"));
}

% insert a sig
define sig() {
    push_spot();
    EXIT_BLOCK {
        pop_spot();
    }

    eol();
    if (bolp()) {
        deln(1);
    } else {
        !if (right(1))
            insert_char('\n');
    }
    insert("-- \n");
    jedrc_insert_sigtext();
}

%}}}
%{{{ Internal to this .jedrc: hacks to support changes in jed 0.99

% In a staggeringly irritating manoeuvre, Mr Davis in his infinite wisdom
% decided to make incompatible changes to create_blocal_var(), strchop()
% and strchopr(), and mkdir. Here we create functions which will work in
% both versions above and below that boundary.

define jedrc_create_blocal_var(name, type) {
    if (_jed_version < 9900)
        create_blocal_var(name, type);
    else
        create_blocal_var(name);
}

define jedrc_strchop(s, delim, quote) {
    variable a, alen, i;

    if (_jed_version >= 9900) {
        a = strchop (s, delim, quote);
        (alen,,) = array_info(a); alen = alen[0];
        for (i = 0; i < alen; i++)
            a[i];
        alen;
    } else
        strchop (s, delim, quote);
}

define jedrc_strchopr(s, delim, quote) {
    variable a, alen, i;

    if (_jed_version >= 9900) {
        a = strchopr (s, delim, quote);
        (alen,,) = array_info(a); alen = alen[0];
        for (i = 0; i < alen; i++)
            a[i];
        alen;
    } else
        strchopr (s, delim, quote);
}

%}}}
%{{{ Internal to this .jedrc: look for a file in the Jed library
define jedrc_is_in_lib(file) {
    variable s = get_jed_library_path();
    variable n, a, alen;

    n = jedrc_strchop (s, ',', 0);
    while (n > 0) {
        s = dircat((), file);
        n--;
        if (1 == file_status(s)) {
            while (n > 0) {
                pop();
                n--;
            }
            return 1;
        }
    }
    return 0;
}
%}}}
%{{{ Various extra modes that may or may not be installed

if (jedrc_is_in_lib("nasm.sl")) { %{{{
    add_mode_for_extension("nasm","asm");
    autoload("nasm_mode", "nasm");
}
%}}}
if (jedrc_is_in_lib("armasm.sl")) { %{{{
    add_mode_for_extension("armasm","s");
    autoload("armasm_mode", "armasm");
}
%}}}
if (jedrc_is_in_lib("timber.sl")) { %{{{
    autoload("timber", "timber");
    autoload("timber_compose", "timber");
    autoload("timber_only", "timber");
    add_completion("timber");
    add_completion("timber_compose");
    setkey("timber_compose", "^Xm");   % replace standard mail-mode
    setkey("timber", "^XM");           % invoke Timber proper
}
%}}}
variable jedrc_have_timberc = 0;
if (jedrc_is_in_lib("timberc.sl")) { %{{{
    () = evalfile("timberc");
    jedrc_have_timberc = 1;
}
%}}}
if (jedrc_is_in_lib("bcmode.sl")) { %{{{
    autoload("bc_mode", "bcmode");
}
if (jedrc_is_in_lib("buttress.sl")) { %{{{
    add_mode_for_extension("buttress","but");
    autoload("buttress_mode", "buttress");
}
%}}}

%}}}
%{{{ ESC 0 inserts `0', so we can type eight zeros using ALT-8 ALT-0
setkey(". 48 insert_char", "^[0");
%}}}
%{{{ Somewhat different text-mode format-paragraph function

define jedrc_on_white() {
    variable i = what_char();
    if (i == ' ' or i == '\t')
        return 1;
    else
        return 0;
}

define text_item1st() {
    push_spot();
    EXIT_BLOCK { pop_spot(); }
    bol();
    if (jedrc_on_white()) {
        skip_white();
        if (looking_at("-") or looking_at("*") or
            looking_at("+")) {
            go_right_1();
            if (jedrc_on_white())
                return 1;
        }
        if (looking_at("(")) {
            skip_chars("^ \t)");
            if (looking_at(")")) {
                go_right_1();
                if (jedrc_on_white())
                    return 1;
            }
        }
    }
    return 0;
}

define text_parsep() {
    push_spot();
    bol_skip_white();
    eolp();
    pop_spot();
}

define text_format_paragraph() {
    variable mkbot, mktop, item, i, j;
    if (text_parsep())
        return;
    push_spot();
    while (1) {
        !if (down(1))
            break;
        if (text_item1st() or text_parsep()) {
            up(1);
            break;
        }
    }
    eol();
    insert("\n");
    mkbot = create_user_mark();
    pop_spot();
    push_spot();
    while (1) {
        if (text_item1st())
            break;
        !if (up(1))
            break;
        if (text_parsep()) {
            go_down(1);
            break;
        }
    }
    bol();
    insert("\n");
    mktop = create_user_mark();
    item = text_item1st();
    if (item) {
        skip_white();
        skip_chars("^ \t");
        push_spot();
        i = what_column();
        skip_white();
        i = what_column() - i - 1;
        pop_spot();
        j = i;
        while (i > 0) {
            insert(".");
            i = i - 1;
        }
        push_spot();
        call("trim_whitespace");
        what_column();
        insert("\n");
        whitespace(());
    }
    call("format_paragraph");
    if (item) {
        pop_spot();
        deln(left(j));
        whitespace(j);
    }
    goto_user_mark(mkbot);
    deln(1);
    goto_user_mark(mktop);
    deln(left(1));
    pop_spot();
}

$1 = "text";
!if (keymap_p($1)) make_keymap($1);
definekey("text_format_paragraph", "\eQ", $1);
define text_mode_hook() {
    use_keymap("text");
    !if (jedrc_have_timberc == 0 or
         (strcmp(".article", whatbuf()) and
          strcmp(".letter", whatbuf())))
        use_syntax_table("TimberC");
    set_buffer_hook("par_sep", "text_parsep");
    runhooks("jedrc_text_mode_hook");
}

%}}}
%{{{ M-x cvs-*
define cvs_log() {
    variable file, dir, name;
    (file, dir, name, ) = getbuf_info();
    if (strcmp(substr(name, 1, 10), "*cvs-log*:") == 0) {
        message("This is already a CVS log buffer\n");
        return;
    }
    if (strcmp(substr(name, 1, 15), "*cvs-annotate*:") == 0) {
        name = substr(name, 16, -1);
    }
    if (strcmp(file, "") == 0) {
        ERROR_BLOCK { error("Unable to determine base file name"); }
        file = get_blocal_var("cvs-file");
    }
    name = "*cvs-log*:" + name;
    change_default_dir(dir);
    sw2buf(name);
    erase_buffer();
    text_mode();
    run_shell_cmd("cvs log " + file);
    setbuf_info((getbuf_info & ~1) | 8); % clear modified bit, set readonly
    bob();
    bol_fsearch("-----");
    recenter(1);
    jedrc_create_blocal_var("cvs-file", 's');
    set_blocal_var(file, "cvs-file");
}
define cvs_annotate() {
    variable file, dir, name, line;
    (file, dir, name, ) = getbuf_info();
    line = what_line();
    if (strcmp(substr(name, 1, 15), "*cvs-annotate*:") == 0) {
        message("This is already a CVS annotation buffer\n");
        return;
    }
    if (strcmp(substr(name, 1, 10), "*cvs-log*:") == 0) {
        name = substr(name, 11, -1);
    }
    if (strcmp(file, "") == 0) {
        ERROR_BLOCK { error("Unable to determine base file name"); }
        file = get_blocal_var("cvs-file");
    }
    name = "*cvs-annotate*:" + name;
    change_default_dir(dir);
    sw2buf(name);
    erase_buffer();
    text_mode();
    run_shell_cmd("cvs annotate " + file);
    setbuf_info((getbuf_info & ~1) | 8); % clear modified bit, set readonly
    goto_line(line);
    recenter(0);
    jedrc_create_blocal_var("cvs-file", 's');
    set_blocal_var(file, "cvs-file");
}
add_completion("cvs_log");
add_completion("cvs_annotate");
%}}}
%{{{ M-x rot13

#ifexists TRANSLATE_ARRAY
variable jedrc_rot13_string = char(255);
for ($1 = 1; $1 < 65; $1++) jedrc_rot13_string += char($1);
for ($1 = 0; $1 < 26; $1++) jedrc_rot13_string += char(65+((13+$1) mod 26));
for ($1 = 91; $1 < 97; $1++) jedrc_rot13_string += char($1);
for ($1 = 0; $1 < 26; $1++) jedrc_rot13_string += char(97+((13+$1) mod 26));
for ($1 = 123; $1 < 255; $1++) jedrc_rot13_string += char($1);
define rot13() {
    % Apparently we can only initialise a char array from a string, and
    % S-Lang strings can't contain NULs; so we are unable to construct
    % TRANSLATE_ARRAY in such a way that it is happy with NULs. :-((
    init_char_array(TRANSLATE_ARRAY, jedrc_rot13_string);
    translate_region ();
}
#else
variable jedrc_rot13_array = String_Type[256];
for ($1 = 0; $1 < 256; $1++) {
    $2 = $1;
    if ($2 >= 65 and $2 < 65+26) $2 = 65 + ($2+13-65) mod 26;
    if ($2 >= 97 and $2 < 97+26) $2 = 97 + ($2+13-97) mod 26;
    jedrc_rot13_array[$1] = char($2);
}

define rot13() {
    translate_region (jedrc_rot13_array);
}
#endif
add_completion("rot13");

%}}}
%{{{ Standard exit hook to allow multiple exit hook registrations

% This is a generally useful exit hook. On an attempt to exit Jed,
% it calls `eval' on the string variable `exit_hook_code'. If this calls
% error() at any point then exit will be abandoned. This allows multiple
% exit hooks to be registered by appending them to the string.
variable sgtatham_exit_hook = 1; % flag it as defined
variable exit_hook_code = ".";
define exit_hook() {
    eval(exit_hook_code);
}

%}}}
%{{{ the pathologically clean-minded M-x polish, which clears *scratch*
define polish() {
    variable buf = whatbuf();
    sw2buf("*scratch*");
    setbuf_info(getbuf_info() &~ 1);
    delbuf("*scratch*");
    sw2buf("*scratch*");
    setbuf_info(getbuf_info() &~ 1);
    sw2buf(buf);
}
%}}}
%{{{ Include local hacks if possible
$1 = expand_filename("~/.jedrc2");
if (file_status($1) == 1) () = evalfile($1);
%}}}
