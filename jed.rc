% -*- mode: slang; mode: fold -*-
% Simon Tatham: version $Revision$

%{{{ load Emacs keybindings to start with

if (BATCH == 0) {
    () = evalfile("emacs");            % Emacs-like bindings
}

%}}}
%{{{ Real Systems(tm) use ^? as delete, so ^H is help

setkey("help_prefix", "^H");

%}}}
%{{{ Key bindings for rectangle kill/insert.

% It isn't as simple as binding kill_rect and insert_rect to keys,
% because those functions also leave the cursor in unhelpful
% places. It's generally more useful to have the cursor at the
% _top_ of the resulting rectangle.

define kill_rect_and_reposition_cursor() {
    variable l1, l2;
    l1 = what_line();
    exchange_point_and_mark();
    l2 = what_line();
    if (l2 > l1)
	exchange_point_and_mark();
    kill_rect();
}

define insert_rect_and_reposition_cursor() {
    variable l1, c1, l2;
    l1 = what_line();
    insert_rect();
    c1 = what_column();
    go_up(what_line() - l1);
    goto_column_best_try(c1);
}

setkey("kill_rect_and_reposition_cursor", "^XL");
setkey("insert_rect_and_reposition_cursor", "^XP");

%}}}
%{{{ FFS, whose silly idea was it to make ` into a quote-next command?
setkey("self_insert_cmd", "`");
%}}}
%{{{ make Backspace work more sensibly in overwrite mode

define jedrc_backspace() {
    if (is_overwrite_mode()) {
        if (bolp()) {
            error("Cannot backspace past start of line in overwrite mode.");
        } else {
            deln(left(1));
            !if (eolp()) {
                insert(" ");
                go_left_1();
            }
        }
    } else {
        call("backward_delete_char_untabify");
    }
}
setkey("jedrc_backspace", "^?");

%}}}
%{{{ In read-only buffers, Space, B, G, g, 0 and Z start to page around
define quick_killbuf() {
    delbuf(whatbuf());
}

define jedrc_ro_internal_alternate(command, char) {
    variable flags;
    (,,,flags) = getbuf_info();
    if (flags & 8)
        call(command);
    else
        call("self_insert_cmd");
}

define jedrc_ro_slang_alternate(command, char) {
    variable flags;
    (,,,flags) = getbuf_info();
    if (flags & 8)
        @command();
    else
        call("self_insert_cmd");
}

setkey (".\"page_down\" \" \" jedrc_ro_internal_alternate", " ");
setkey (".\"page_up\" \"b\" jedrc_ro_internal_alternate", "b");
setkey (".\"page_up\" \"B\" jedrc_ro_internal_alternate", "B");
setkey (".\"beg_of_buffer\" \"g\" jedrc_ro_internal_alternate", "g");
setkey (".\"beg_of_buffer\" \"0\" jedrc_ro_internal_alternate", "0");
setkey (".\"end_of_buffer\" \"G\" jedrc_ro_internal_alternate", "G");
setkey (".\"end_of_buffer\" \"z\" jedrc_ro_internal_alternate", "z");
setkey (".\"end_of_buffer\" \"Z\" jedrc_ro_internal_alternate", "Z");
setkey ("jedrc_ro_slang_alternate(&quick_killbuf,\"q\")", "q");
setkey ("jedrc_ro_slang_alternate(&quick_killbuf,\"Q\")", "Q");
setkey ("jedrc_ro_slang_alternate(&search_forward,\"/\")", "/");
setkey ("jedrc_ro_slang_alternate(&search_backward,\"?\")", "?");

% We have to do this to override slang_mode's underhand funtation of
% the C mode keymap
define slang_mode_hook() {
    local_setkey(".\"page_down\" \" \" jedrc_ro_internal_alternate", " ");
}

%}}}
%{{{ ^X^D to insert the date; ^X4^D/^X4d to insert eight-digit dates

% insert date
define insert_date() {
    variable t = time;
    insert(sprintf("%s-%s-%s", substr(t,9,2),
                   substr(t,5,3), substr(t,21,4)));
}
setkey("insert_date", "^X^D");

% insert 8-digit date
define insert_8dig_date(s) {
    variable t = time;
    variable y, m, nm, d;
    d = substr(t,9,2);
    if (substr(d,1,1) == " ")
        d = "0" + substr(d,2,1);
    m = substr(t,5,3);
    nm = (is_substr("----Jan-Feb-Mar-Apr-May-Jun-Jul-Aug-Sep-Oct-Nov-Dec-", m)
          / 4);
    y = substr(t,21,4);
    insert(sprintf("%s%s%02d%s%s", y, s, nm, s, d));
}
setkey("insert_date", "^X^D");
setkey(". \"-\" insert_8dig_date", "^X4^D");
setkey(". \"\" insert_8dig_date", "^X4d");
setkey(". \"\" insert_8dig_date", "^X4D");

%}}}
%{{{ Extra bindings: ^X^I to toggle insert mode, ^Xg to go to line
setkey("toggle_overwrite", "^X^I");
setkey("goto_line_cmd", "^Xg");
%}}}
%{{{ turn off the menu bar

% disable top menu bar
enable_top_status_line (0);

#ifdef MSWINDOWS
#ifexists destroy_menubar
destroy_menubar();
#endif
#ifexists w32_destroy_menubar
w32_destroy_menubar();
#endif
#endif

% The menu bar is getting more and more persistent: here I define
% away all the various key commands that activate it.
unsetkey("^[E"); unsetkey("^[e");
unsetkey("^[S"); unsetkey("^[s");
unsetkey("^[I"); unsetkey("^[i");
unsetkey("^[H"); unsetkey("^[h");
unsetkey("^[[21~");

%}}}
%{{{ Ctrl+arrows under X are more annoying than useful; disable them
unsetkey("^[[^A");
unsetkey("^[[^B");
unsetkey("^[[^C");
unsetkey("^[[^D");
%}}}
%{{{ file functions: ^X^R, M-x cd, M-x revert, M-x insh

define find_file_read_only() {
    variable file;
    file = read_file_from_mini ("Find file read-only:");
    !if (strlen (extract_filename(file))) return;

    find_file (file);
    pop();
    set_readonly(1);
}

define set_buffer_dir (dir) {
    variable buf, flags;
    (, buf, flags) = getbuf_info();
    setbuf_info (dir, buf, flags);
}

define cd() {
    variable dir;
    dir = read_file_from_mini ("Change buffer directory to:");
    if (file_status(dir) != 2) {
        error("Expecting directory name.");
        return;
    }
    set_buffer_dir (dir);
}

define revert() {
    variable file, dir, line, col;

    (file,dir,,) = getbuf_info();
    file = dircat(dir,file);

    line = what_line(); col = what_column();
    delbuf (whatbuf());
    !if (find_file (file)) message ("File has disappeared! New file.");
    goto_line(line); goto_column_best_try(col);
}

define insh() {
    variable cmd;
    cmd = read_mini ("$", "", "");
    if (strlen(cmd) > 0) {
	run_shell_cmd (cmd);
    }
}

setkey("find_file_read_only", "^X^R");

%}}}
%{{{ F7 to execute macro

#ifdef MSDOS MSWINDOWS
setkey("execute_macro", "^@A");
#else
setkey("execute_macro", "^[[18~");
#endif

%}}}
%{{{ bookmark functions: F3 to insert bookmark, F4 to go to it
variable bookmark_str = "\176\174\176";
define set_bookmark() {
    insert(bookmark_str);
}
define goto_bookmark() {
    variable bkmk_fun = "%jedrc_bookmark%";
    variable bkmk_var = "jedrc_bookmark_returnpoint";
    variable repeat, mark;
    push_spot();
    if (strcmp(LAST_KBD_COMMAND, bkmk_fun)) {
        % Last keyboard action wasn't another goto-bookmark, so we
        % must start from the top. Save the start position so we
        % can come back if all bookmarks are exhausted.
        create_blocal_var(bkmk_var);
        set_blocal_var(create_user_mark(), bkmk_var);
        bob();
        repeat = 0;
    } else {
        % Our last kbd action was to go to and remove another
        % bookmark. So we replace that one, and search on from
        % there.
        set_bookmark();
        repeat = 1;
    }
    if (fsearch(bookmark_str)) {
        mark = create_user_mark();
        pop_spot();
        goto_user_mark(mark);
        deln(strlen(bookmark_str));
        message("Found and removed bookmark.");
        set_current_kbd_command(bkmk_fun);
    } else {
        pop_spot();
        if (repeat) {
            message("No more bookmarks.");
            goto_user_mark(get_blocal_var(bkmk_var));
        } else {
            error("No bookmark found.");
        }
    }
}
#ifdef MSDOS MSWINDOWS
setkey("set_bookmark", "^@=");
setkey("goto_bookmark", "^@>");
#else
setkey("set_bookmark", "^[[13~");
setkey("goto_bookmark", "^[[14~");
setkey("set_bookmark", "^[OR");
setkey("goto_bookmark", "^[OS");
setkey("set_bookmark", "^[[[C");
setkey("goto_bookmark", "^[[[D");
#endif
%}}}
%{{{ F6 to indent a line, trim whitespace from the end, and go to next line
define indent_trim_goto_next() {
    call("indent_line");
    eol();
    trim();
    go_right_1();
}
#ifdef MSDOS MSWINDOWS
setkey("indent_trim_goto_next", "^@@");
#else
setkey("indent_trim_goto_next", "^[[17~");
#endif

%}}}
%{{{ shell grep_goto function: F9

define grep_goto() {
    variable filename, line;
    push_spot();
    bol_skip_white();
    push_mark();
    skip_chars("^:\n");
    filename = bufsubstr();
    line = 1;
    if (looking_at(":")) {
        go_right_1();
        push_mark();
        skip_chars("^:\n");
        line = integer(bufsubstr());
    }
    pop_spot();
    if (find_file(filename))
        goto_line(line);
}

#ifdef MSDOS MSWINDOWS
setkey("grep_goto", "^@C");
#else
setkey("grep_goto", "^[[20~");
#endif
%}}}
%{{{ disable isearch and enable regexp search

setkey("search_forward", "^S");
setkey("search_backward", "^R");

setkey("re_search_forward", "^[^S");
setkey("re_search_backward", "^[^R");

%}}}
%{{{ redefine bits of C and SLang mode

% Not entirely sure about this, but we might be required to set the
% cmode variables _after_ cmode is loaded, so I'll put them in a
% function here and we can set them both at .jedrc run time and in
% our C mode hook.
define jedrc_set_cmode_vars() %{{{
{
    % C-mode variables
    C_INDENT        = 4;	       % indent within block  
    C_BRACE         = 0;	       % indent for brace  
    C_BRA_NEWLINE   = 0;	       % don't insert a newline before '{'  
    C_Colon_Offset  = 2;	       % indent case statements by two  
    C_CONTINUED_OFFSET = 4;	       % indent for unbraced then-clauses  
    C_Preprocess_Indent = 0;	       % indent for nested #if/#endifs  
#ifexists C_Class_Offset
    C_Class_Offset  = 4;	       % still indent by 4 in a C++ class
#endif
}
%}}}

define jedrc_simple_par_sep() %{{{
{
    bol_skip_white();
    eolp();
}
%}}}

define insert_openbrace_cmd () %{{{
{
    insert_char ('{');
    indent_line ();
}
%}}}
define insert_shutbrace_cmd () %{{{
{
    insert_char ('}');
    indent_line ();

    call("backward_delete_char");
    call("self_insert_cmd");           % so we get the blink!
}
%}}}
define c_multiline_comment() %{{{
{
    bol();
    skip_white();
    !if (eolp()) {
        bol();
        insert_char('\n');
        go_left(1);
    }
    insert("/*\n*\n*/");
    go_up(2);
    indent_line();
    go_down(2);
    indent_line();
    go_up(1);
    indent_line();
    eol();
    insert(" ");
}
%}}}
define c_mode_hook() %{{{
{
    variable keymap;
    keymap = what_keymap();
    definekey("insert_openbrace_cmd", "{", keymap);
    definekey("insert_shutbrace_cmd", "}", keymap);
    definekey("c_multiline_comment", "^XC", keymap);
    definekey("jedrc_c_format_paragraph", "^[Q", keymap);
    definekey("jedrc_c_format_paragraph", "^[q", keymap);
#ifexists set_buffer_hook
    set_buffer_hook ("par_sep", "jedrc_simple_par_sep");
#endif
    jedrc_set_cmode_vars();
}
%}}}
define slang_mode_hook() %{{{
{
    c_mode_hook();
}
%}}}

%}}}
%{{{ redefine bits of Perl mode

define perl_mode_hook()
{
    variable keymap;
    keymap = what_keymap();
    % Currently Perl mode doesn't have its own keymap. If that ever
    % changes, we don't want to have to fix this bit of jedrc!
    if (keymap == "global") {
        keymap = "perl";
        !if (keymap_p ($1)) make_keymap ($1);
        use_keymap(keymap);
    }
    definekey("jedrc_perl_format_paragraph", "^[Q", keymap);
    definekey("jedrc_perl_format_paragraph", "^[q", keymap);
#ifexists unset_buffer_hook
    unset_buffer_hook("par_sep");
#endif
}

%}}}
%{{{ redefine bits of Python mode

define python_mode_hook()
{
    variable keymap;
    keymap = what_keymap();
    % Python and Perl share a comment syntax, so we can use
    % perl_format_para for both.
    definekey("jedrc_perl_format_paragraph", "^[Q", keymap);
    definekey("jedrc_perl_format_paragraph", "^[q", keymap);
#ifexists unset_buffer_hook
    unset_buffer_hook("par_sep");
#endif
}

%}}}
%{{{ redefine bits of armasm mode

define armasm_mode_hook() %{{{
{
    variable keymap;
    keymap = what_keymap();
    definekey("jedrc_armasm_format_paragraph", "^[Q", keymap);
    definekey("jedrc_armasm_format_paragraph", "^[q", keymap);
#ifexists unset_buffer_hook
    unset_buffer_hook("par_sep");
#endif
}

%}}}

%}}}
%{{{ redefine bits of PS mode

define ps_mode_hook() %{{{
{
    variable keymap;
    keymap = what_keymap();
    definekey("jedrc_ps_format_paragraph", "^[Q", keymap);
#ifexists unset_buffer_hook
    unset_buffer_hook("par_sep");
#endif
}

%}}}

%}}}
%{{{ redefine bits of Lisp mode

define lisp_mode_hook() %{{{
{
    variable keymap;
    keymap = what_keymap();
    definekey("jedrc_lisp_format_paragraph", "^[Q", keymap);
    definekey("jedrc_lisp_format_paragraph", "^[q", keymap);
#ifexists unset_buffer_hook
    unset_buffer_hook("par_sep");
#endif
}

%}}}

%}}}
%{{{ ensure bash scripts are edited in sh mode, and fiddle with sh mode

define bash_mode() {
    sh_mode();
}

define sh_mode_hook() {
    variable keymap;
    keymap = what_keymap();
    definekey(".\"# \" jedrc_format_paragraph", "^[Q", keymap);
    definekey(".\"# \" jedrc_format_paragraph", "^[q", keymap);
}

%}}}
%{{{ ^X F is death; disable it
unsetkey("^Xf");
unsetkey("^XF");
%}}}
%{{{ ^X T to open a new temp buffer with no attached file
define make_temp_buffer() {
    variable bufname, number;

    bufname = "*temp*";
    number = 0;
    while (bufferp(bufname)) {
	number++;
	bufname = Sprintf("*temp%d*", number, 1);
    }
    sw2buf(bufname);
    setbuf_info(getbuf_info() | 0x20); % enable undo
    erase_buffer();
    text_mode();
}

setkey("make_temp_buffer", "^Xt");
setkey("make_temp_buffer", "^XT");
%}}}
%{{{ global variables

#ifdef VMS UNIX
USE_ANSI_COLORS = 1;
#endif
No_Backups = 1;
Startup_With_File = 0;
DISPLAY_TIME = 1;
HIGHLIGHT = 1;
WANT_SYNTAX_HIGHLIGHT = 1;
#ifdef MSDOS
HORIZONTAL_PAN = -1;                   % pan *whole* window
LINENUMBERS = 2;                       % display line and column numbers
#else
HORIZONTAL_PAN = 20;                   % pan current line only
LINENUMBERS = 1;                       % display line numbers
#endif
BLINK = 1;                             % blink matching parenthesis
TAB_DEFAULT = 8;
WRAP = 70;                             % wrap column
ADD_NEWLINE = 0;                       % add newline to file if not present
IGNORE_BEEP = 1;                       % beep terminal during error messages
_traceback = 0;                        % don't dump traceback on S-Lang errors
WRAP_INDENTS = 0;                      % don't indent next line after wrapping
#ifndef MSDOS OS2 MSWINDOWS
OUTPUT_RATE    = 0;
#endif
Fold_Mode_Ok = 1;

jedrc_set_cmode_vars();

#ifdef UNIX
variable UCB_Mailer; UCB_Mailer = "/usr/ucb/mail";
#endif

#ifdef MSDOS XWINDOWS
ALT_CHAR = 27;                         % the Meta- or Alt-key prefix
#endif

META_CHAR       = -1;   % All chars with hi bit set will self insert

#ifdef MSDOS OS2
DISPLAY_EIGHT_BIT = 1;
#else
DISPLAY_EIGHT_BIT = 160; % Other systems assume ISO Latin 1
#endif

%}}}
%{{{ colours

#ifdef XWINDOWS %{{{
set_color("normal", "#cccccc", "#000000");
set_color("status", "#ffff55", "#0000bb");
set_color("region", "#000000", "#bbbbbb");
set_color("operator", "#ffffff", "#000000");   % +, -, etc..
set_color("number", "#5555ff", "#000000");     % 10, 2.71, etc..
set_color("comment", "#bbbb00", "#000000");    % /* comment */
set_color("string", "#00bb00", "#000000");     % "string" or 'char'
set_color("keyword", "#ff5555", "#000000");    % if, while, unsigned, ...
set_color("keyword1", "#55ff55", "#000000");   % exit, NULL, strcpy, ...
set_color("delimiter", "#ffff55", "#000000");  % {}[](),.;...
set_color("preprocess", "#00bbbb", "#000000"); % #ifdef ....
set_color("menu", "#ffffff", "#0000bb");       % menu bar
set_color("message", "#cccccc", "#000000");    % colour for messages
set_color("error", "#ffff55", "#bb0000");      % colour for errors
set_color("dollar", "#bb0000", "#000000");     % dollar sign continuation
set_color("...", "#55ff55", "#000000");        % fold indicator

call("redraw");
%}}}
#else
#ifdef MSWINDOWS %{{{
set_color("normal", "204,204,204", "00,00,00");
set_color("status", "255,255,55", "00,00,187");
set_color("region", "00,00,00", "187,187,187");
set_color("operator", "255,255,255", "00,00,00");   % +, -, etc..
set_color("number", "55,55,255", "00,00,00");     % 10, 2.71, etc..
set_color("comment", "187,187,00", "00,00,00");    % /* comment */
set_color("string", "00,187,00", "00,00,00");     % "string" or 'char'
set_color("keyword", "255,55,55", "00,00,00");    % if, while, unsigned, ...
set_color("keyword1", "55,255,55", "00,00,00");   % exit, NULL, strcpy, ...
set_color("delimiter", "255,255,55", "00,00,00");  % {}[](),.;...
set_color("preprocess", "00,187,187", "00,00,00"); % #ifdef ....
set_color("menu", "255,255,255", "00,00,187");       % menu bar
set_color("message", "204,204,204", "00,00,00");    % colour for messages
set_color("error", "255,255,55", "187,00,00");      % colour for errors
set_color("dollar", "187,00,00", "00,00,00");     % dollar sign continuation
set_color("...", "55,255,55", "00,00,00");        % fold indicator

call("redraw");
%}}}
#else %{{{
set_color("normal", "lightgray", "black");
set_color("status", "yellow", "blue");
set_color("region", "black", "lightgray");
set_color("operator", "white", "black");       % +, -, etc..
set_color("number", "brightblue", "black");    % 10, 2.71, etc..
set_color("comment", "brown", "black");        % /* comment */
set_color("string", "green", "black");         % "string" or 'char'
set_color("keyword", "brightred", "black");    % if, while, unsigned, ...
set_color("keyword1", "brightgreen", "black"); % exit, NULL, strcpy, ...
set_color("delimiter", "yellow", "black");     % {}[](),.;...
set_color("preprocess", "cyan", "black");      % #ifdef ....
set_color("menu", "white", "blue");            % menu bar
set_color("message", "lightgray", "black");    % colour for messages
set_color("error", "yellow", "red");           % colour for errors
set_color("dollar", "red", "black");           % dollar sign continuation
set_color("...", "brightgreen", "black");      % fold indicator

#ifdef UNIX VMS
if (USE_ANSI_COLORS) call ("redraw");
#else
call("redraw");
#endif
%}}}
#endif
#endif

#ifexists _Jed_Color_Scheme
% Gah. This is a new and irritating scheme whereby I can't define
% my colours in .jedrc because they will be trampled on
% subsequently by the default-colour-scheme mechanism, unless I set
% this variable to inform Jed it shouldn't invoke the default.
_Jed_Color_Scheme = "ooh";
#endif

%}}}
%{{{ terminal setup for Unix

#ifdef UNIX
$1 = "vt100 vt102 vt200 dec-vt220 vt300 vt320 vt420 xterms sterm";
if (is_substr($1, getenv("TERM"))) set_term_vtxxx(0);
#endif

%}}}
%{{{ M-x i1 to i8, t1 to t8, gnu

%
% Choose C indentation
%
define i(ind) { %{{{
    variable mode;

    (, mode) = what_mode();
    if (mode & 2) {
        C_INDENT = ind;
        C_BRACE = 0;
        C_CONTINUED_OFFSET = ind;
        C_Colon_Offset = ind/2;
    }
} %}}}
define gnu() { %{{{
    variable mode;

    (, mode) = what_mode();
    if (mode & 2) {
        C_INDENT = 2;
        C_BRACE = 2;
        C_CONTINUED_OFFSET = 2;
    }
} %}}}
define davis() { %{{{
    variable mode;

    (, mode) = what_mode();
    if (mode & 2) {
        C_INDENT = 3;
        C_BRACE = 2;
        C_CONTINUED_OFFSET = 2;
    }
} %}}}

define i1() { i(1); }
define i2() { i(2); }
define i3() { i(3); }
define i4() { i(4); }
define i5() { i(5); }
define i6() { i(6); }
define i7() { i(7); }
define i8() { i(8); }

% Insert a "tab" of as many columns as desired. Use "real" tab characters
% iff we're at the beginning of a line
variable VAR_TAB_SIZE;
VAR_TAB_SIZE = 2;
define var_tab() { %{{{
    variable i, j;
    push_spot();
    bskip_chars (" \t");
    if (bolp()) {
        pop_spot();
        i = what_column() + VAR_TAB_SIZE - 1;
        i = i - (i mod VAR_TAB_SIZE);
        insert_char('.');
        bol();
        trim();
        whitespace(i);
        call("delete_char_cmd");
    } else {
        pop_spot();
        j = (what_column() - 1) mod VAR_TAB_SIZE;
        i = TAB;
        TAB = 0;
        whitespace (VAR_TAB_SIZE - j);
        TAB = i;
    }
} %}}}

define t(tab) { %{{{
    VAR_TAB_SIZE = tab;
    local_setkey("var_tab", "^I");
} %}}}

define t1() { t(1); }
define t2() { t(2); }
define t3() { t(3); }
define t4() { t(4); }
define t5() { t(5); }
define t6() { t(6); }
define t7() { t(7); }
define t8() { local_setkey("self_insert_cmd", "^I"); }
define t9() { t(9); }
define t10() { t(10); }

%}}}
%{{{ M-x underline and M-x underline-double

define jedrc_underline(s) {
    variable i, len;
    push_spot();
    i = what_column();
    go_up_1();
    eol();
    i = what_column() - i;
    pop_spot();
    len = strlen(s);
    while (i > 0) {
        insert(s);
        i = i - len;
    }
}

define underline() { jedrc_underline("-"); }
define underline_double() { jedrc_underline("="); }

add_completion("underline");
add_completion("underline_double");

%}}}
%{{{ ^X^] to show column

define showcolm() {
    message(Sprintf("Cursor is at column %d", what_column(), 1));
}
setkey("showcolm", "^X^]");

%}}}
%{{{ makefile_mode, or hacks thereabout

define makefile_mode() {
    sh_mode();
}

% For some horrifying reason which I have yet to explain, Debian
% jed 0.99.15 on ixion appears to call .jedrc twice, which causes
% the code below to end up in an infinite loop of
% jedrc_default_mode calling itself. Wrapping it in #ifnexists
% solves the immediate problem.
#ifnexists jedrc_old_defmode

variable jedrc_old_defmode = Default_Mode;

define jedrc_default_mode() {
    variable name;
    (name,,,) = getbuf_info();
    name = extract_filename(name);
    if (
#ifdef MSDOS MSWINDOWS
	strup(name) == "MAKEFILE"
#else
	name == "Makefile" or name == "makefile"
#endif
	)
        makefile_mode();
    else
        @jedrc_old_defmode();
}

Default_Mode = &jedrc_default_mode;

#endif

%}}}
%{{{ M-x q, Q, rq/sq/qq and sig

% for e-mail and news: quote a paragraph
define q() {
    push_spot();
    EXIT_BLOCK {
        pop_spot();
    }

    bol();
    if (eolp())
        break;

    while ((what_char() != '\n') and (bobp() == 0)) {
        go_up(1);
        bol();
    }
    if (what_char() == '\n')
        go_down(1);
    bol();
    while ((what_char() != '\n') and (eobp() == 0)) {
        insert("> ");
        !if (down(1))
            break;
        bol();
    }
}

% and un-quote it again
define Q() {
    push_spot();
    EXIT_BLOCK {
        pop_spot();
    }

    bol();
    if (eolp())
        break;

    while ((what_char() != '\n') and (bobp() == 0)) {
        go_up(1);
        bol();
    }
    if (what_char() == '\n')
        go_down(1);
    bol();
    while ((what_char() != '\n') and (eobp() == 0)) {
        if (what_char() == '>')
            call("delete_char_cmd");
        if (what_char() == ' ')
            call("delete_char_cmd");
        !if (down(1))
            break;
        bol();
    }
}

% Re-cast a (multi-)quoted paragraph in Richard K's quoting style
define rq() {
    push_spot();
    EXIT_BLOCK {
        pop_spot();
    }

    bol();
    if (eolp())
        break;

    while ((what_char() != '\n') and (bobp() == 0)) {
        go_up(1);
        bol();
    }
    if (what_char() == '\n')
        go_down(1);
    bol();
    while ((what_char() != '\n') and (eobp() == 0)) {
        if (what_char() == '>') {
            while (what_char() == '>') {
                go_right_1();
                push_mark();
                skip_white();
                if (eolp() or what_char() != '>') {
                    pop_mark(1);
                    break;
                }
                del_region();
            }
            if (what_char() != ' ' and what_char() != '\t')
               insert_char(' ');
            bol();
        }
        !if (down(1))
            break;
        bol();
    }
}

% Re-cast a multilevel quoted paragraph in my attribution style
define sq() {
    variable qlevel, mlevel, ignorelevel, seen, snippet, dodown, top;
    variable realtop;

    bol();
    if (eolp())
        break;

    while ((what_char() != '\n') and (bobp() == 0)) {
        go_up(1);
        bol();
    }
    if (what_char() == '\n')
        go_down(1);
    bol();

    realtop = create_user_mark();
    EXIT_BLOCK {
        goto_user_mark(realtop);
    }

    % The effect we want is as follows: an _attribution line_ is defined
    % as a line of quoting level N (may be 0) that occurs before any lines
    % of quoting level N+1 that _aren't attributions_. (That proviso is
    % really important: it causes the whole transformation to become
    % idempotent, and makes it continue to work when it sees a mixture of
    % this attribution style and the traditional one.)

    % The algorithm we adopt is as follows: we scan down the paragraph and
    % find the maximum quoting level M. We then scan down the paragraph
    % again and take out all the lines before the first M-level line that
    % aren't (M-1) level, i.e. _aren't_ attributions. Then we proceed
    % further down until we see a non-M-level line and insert all those
    % lines we took out. This will cause the M-level lines to be preceded
    % only by their attribution at the top of the paragraph. We then
    % repeat the whole process starting from just below the M-level lines.
    %
    % Because of the possibility of interleaved text, we ignore all lines
    % of a quoting level we have already dealt with in subsequent steps.

    ignorelevel = -1;
    top = create_user_mark();
    forever {
        mlevel = 0;
        % Scan to find M.
        goto_user_mark(top);
        while ((what_char() != '\n') and (eobp() == 0)) {
            % Measure the quoting level of the line.
            qlevel = 0;
            while (what_char() == '>') {
                qlevel++;
                go_right_1();
                skip_white();
                if (eolp() or what_char() != '>') {
                    break;
                }
            }
            if ((ignorelevel < 0 or qlevel < ignorelevel) and
                mlevel < qlevel)
                mlevel = qlevel;

            !if (down(1))
                break;
            bol();
        }

        % If M == 0, we've finished.
        if (mlevel == 0)
            break;

        % Having found M, move all things above the first M line that aren't
        % level M-1 to just after the first contiguous block of M lines.
        seen = 0;
        snippet = "";
        goto_user_mark(top);
        while ((what_char() != '\n') and (eobp() == 0)) {
            % Measure the quoting level of the line.
            qlevel = 0;
            while (what_char() == '>') {
                qlevel++;
                go_right_1();
                skip_white();
                if (eolp() or what_char() != '>') {
                    break;
                }
            }
            dodown = 1;
            % If we haven't yet seen an M line...
            if (seen == 0) {
                if (qlevel == mlevel) {
                    % ... and this is one, then now we have. :-)
                    seen = 1;
                } else if (qlevel != mlevel-1) {
                    % ... but if this isn't M or M-1 then snip it.
                    bol(); push_mark(); eol(); snippet += bufsubstr() + "\n";
                    bol(); push_mark(); eol(); go_right_1(); del_region();
                    dodown = 0;
                }
            } else {
                % If we have seen an M line, then we stop if this isn't one.
                if (qlevel != mlevel) {
                    bol();
                    top = create_user_mark();
                    insert(snippet);
                    snippet = "";
                    break;
                }
            }

            if (dodown) {
                !if (down(1)) {
                    eol();
                    break;
                }
            }
            bol();
        }

        % Robustness: if we've reached end of paragraph and the snippet
        % hasn't been pasted, paste it.
        if (snippet != "") {
            !if (bolp())
                insert("\n");          % just in case EOF
            insert(snippet);
        }

        pop_spot();

        ignorelevel = mlevel;
    }
}

% do all quoting things
define qq() {
    rq();
    sq();
}

% the core routine to actually insert the sig text
define jedrc_insert_sigtext() {
    variable f = expand_filename("~/.sigs/Makesig");
    if (1 == file_status(f))
        run_shell_cmd("perl " + f);
    else
        () = insert_file(expand_filename("~/.signature"));
}

% insert a sig
define sig() {
    push_spot();
    EXIT_BLOCK {
        pop_spot();
    }

    eol();
    if (bolp()) {
        deln(1);
    } else {
        !if (right(1))
            insert_char('\n');
    }
    insert("-- \n");
    jedrc_insert_sigtext();
}

%}}}
%{{{ Internal to this .jedrc: hacks to support changes in jed 0.99

% In a staggeringly irritating manoeuvre, Mr Davis in his infinite wisdom
% decided to make incompatible changes to create_blocal_var(), strchop()
% and strchopr(), and mkdir. Here we create functions which will work in
% both versions above and below that boundary.

define jedrc_create_blocal_var(name, type) {
    if (_jed_version < 9900)
        create_blocal_var(name, type);
    else
        create_blocal_var(name);
}

define jedrc_strchop(s, delim, quote) {
    variable a, alen, i;

    if (_jed_version >= 9900) {
        a = strchop (s, delim, quote);
        (alen,,) = array_info(a); alen = alen[0];
        for (i = 0; i < alen; i++)
            a[i];
        alen;
    } else
        strchop (s, delim, quote);
}

define jedrc_strchopr(s, delim, quote) {
    variable a, alen, i;

    if (_jed_version >= 9900) {
        a = strchopr (s, delim, quote);
        (alen,,) = array_info(a); alen = alen[0];
        for (i = 0; i < alen; i++)
            a[i];
        alen;
    } else
        strchopr (s, delim, quote);
}

%}}}
%{{{ Internal to this .jedrc: look for a file in the Jed library
define jedrc_is_in_lib(file) {
    variable s = get_jed_library_path();
    variable n, a, alen;

    n = jedrc_strchop (s, ',', 0);
    while (n > 0) {
        s = dircat((), file);
        n--;
        if (1 == file_status(s)) {
            while (n > 0) {
                pop();
                n--;
            }
            return 1;
        }
    }
    return 0;
}
%}}}
%{{{ Various extra modes that may or may not be installed

if (jedrc_is_in_lib("nasm.sl")) { %{{{
    add_mode_for_extension("nasm","asm");
    autoload("nasm_mode", "nasm");
}
%}}}
if (jedrc_is_in_lib("armasm.sl")) { %{{{
    add_mode_for_extension("armasm","s");
    autoload("armasm_mode", "armasm");
}
%}}}
if (jedrc_is_in_lib("timber.sl")) { %{{{
    autoload("timber", "timber");
    autoload("timber_compose", "timber");
    autoload("timber_only", "timber");
    autoload("timber_goto", "timber");
    add_completion("timber");
    add_completion("timber_compose");
    setkey("timber_compose", "^Xm");   % replace standard mail-mode
    setkey("timber", "^XM");           % invoke Timber proper
    setkey("timber_goto", "^X^M");     % invoke Timber straight to a folder
}
%}}}
variable jedrc_have_timberc = 0;
if (jedrc_is_in_lib("timberc.sl")) { %{{{
    () = evalfile("timberc");
    jedrc_have_timberc = 1;
}
%}}}
if (jedrc_is_in_lib("bcmode.sl")) { %{{{
    autoload("bc_mode", "bcmode");
}
%}}}
if (jedrc_is_in_lib("outline.sl")) { %{{{
    autoload("outline_mode", "outline");
}
%}}}
if (jedrc_is_in_lib("halibut.sl")) { %{{{
    add_mode_for_extension("halibut","but");
    autoload("halibut_mode", "halibut");
} else if (jedrc_is_in_lib("buttress.sl")) {
    add_mode_for_extension("buttress","but");
    autoload("buttress_mode", "buttress");
}
%}}}
if (jedrc_is_in_lib("treemode.sl")) { %{{{
    autoload("du_mode", "treemode");
}
%}}}
if (jedrc_is_in_lib("diarymode.sl")) { %{{{
    autoload("diary_mode", "diarymode");
}
%}}}
if (jedrc_is_in_lib("sokoban.sl")) { %{{{
    autoload("sokoban", "sokoban");
}
%}}}

% Also, .m is Objective-C, for Mac OS X work.
add_mode_for_extension("c", "m");

% Mostly for Gareth: .phtml is HTML.
add_mode_for_extension("html","phtml");

%}}}
%{{{ ESC 0 inserts `0', so we can type eight zeros using ALT-8 ALT-0
setkey(". 48 insert_char", "^[0");
%}}}
%{{{ Somewhat different format-paragraph functions

define jedrc_on_white() {
    variable i = what_char();
    if (i == ' ' or i == '\t')
        return 1;
    else
        return 0;
}

define jedrc_item1st(prefix) {
    push_spot();
    EXIT_BLOCK { pop_spot(); }
    bol();
    if (prefix != "") {
	skip_white();
	if (looking_at(prefix))
	    go_right(strlen(prefix));
	else
	    return 0;
    }
    if (jedrc_on_white()) {
        skip_white();
        if (looking_at("-") or looking_at("*") or
            looking_at("+")) {
            go_right_1();
            if (jedrc_on_white())
                return 1;
        }
        if (looking_at("(")) {
            skip_chars("^ \t)");
            if (looking_at(")")) {
                go_right_1();
                if (jedrc_on_white())
                    return 1;
            }
        }
    }
    return 0;
}

define jedrc_parsep(prefix) {
    variable buf;

    push_spot();
    bol_skip_white();
    if (prefix != "") {
	if (looking_at(prefix)) {
	    go_right(strlen(prefix));
	} else {
	    pop_spot();
	    return 1;
	}
    }
    buf = whatbuf();
    if (looking_at("-- "))
	go_right(3);
    else if (andelse {looking_at("--This line, and those below, will be ignored--")}
	     {substr(buf, 1, 11) == "svn-commit."}
	     {strlen(buf) > 3}
	     {substr(buf, strlen(buf)-3, 4) == ".tmp"})
	go_right(47);
    else if (andelse {looking_at("CVS: ----------------------------------------------------------------------")}
	     {substr(buf, 1, 3) == "cvs"})
	go_right(75);
    eolp();
    pop_spot();
}

define jedrc_format_paragraph(prefix) {
    variable mkbot, mktop, item, i, j, thisprefix, prefixlen, col;
    if (jedrc_parsep(prefix))
        return;
    push_spot();
    while (1) {
        !if (down(1))
            break;
        if (jedrc_item1st(prefix) or jedrc_parsep(prefix)) {
            up(1);
            break;
        }
    }
    eol();
    insert("\n");
    mkbot = create_user_mark();
    pop_spot();
    push_spot();
    while (1) {
        if (jedrc_item1st(prefix))
            break;
        !if (up(1))
            break;
        if (jedrc_parsep(prefix)) {
            go_down(1);
            break;
        }
    }
    bol();
    insert("\n");
    mktop = create_user_mark();
    item = jedrc_item1st(prefix);
    prefixlen = 0;
    if (prefix != "") {
	bol();
	while (not eolp()) {
	    push_mark();
	    push_mark();
	    skip_white();
	    if (looking_at(prefix))
		go_right(strlen(prefix));
	    prefixlen = what_column();
	    thisprefix = bufsubstr();
	    skip_white();
	    col = what_column();
	    del_region();
	    whitespace(col - prefixlen);
	    eol();
	    go_right_1();
	}
	goto_user_mark(mktop);
    }
    if (item) {
        skip_white();
        skip_chars("^ \t");
        push_spot();
        i = what_column();
        skip_white();
        i = what_column() - i - 1;
        pop_spot();
        j = i;
        while (i > 0) {
            insert(".");
            i = i - 1;
        }
        push_spot();
        call("trim_whitespace");
        what_column();
        insert("\n\n");
        whitespace(());
    }
    WRAP -= prefixlen;
    call("format_paragraph");
    WRAP += prefixlen;
    if (item) {
        pop_spot();
	deln(1);
	i = what_column();
	push_mark();
	go_down_1();
	bol_skip_white();
	what_column();
	trim();
	del_region();
        deln(left(j));
        whitespace(j);
	whitespace(() - i);
    }
    if (prefix != "") {
	goto_user_mark(mktop);
	bol();
	while (not eolp()) {
	    push_mark();
	    skip_white();
	    col = what_column();
	    del_region();
	    insert(thisprefix);
	    whitespace(col - 1);
	    eol();
	    go_right_1();
	}
    }
    goto_user_mark(mkbot);
    deln(1);
    goto_user_mark(mktop);
    deln(left(1));
    pop_spot();
}

% To allow paragraph formatting in SLang mode to work properly, we
% need cmode_is_slang_mode listed as an autoload if it isn't
% already defined.
#ifexists cmode_is_slang_mode
% it's defined, we're safe
#else
autoload("cmode_is_slang_mode", "cmode");
#endif

define jedrc_c_get_prefix() {
    if (cmode_is_slang_mode())
        return "% ";
    push_spot();
    EXIT_BLOCK { pop_spot(); }
    bol();
    skip_white();
    if (looking_at("//")) {
	return "// ";
    }
    return "* ";
}

define jedrc_text_format_paragraph() {
    jedrc_format_paragraph("");
}
define jedrc_c_format_paragraph() {
    jedrc_format_paragraph(jedrc_c_get_prefix());
}
define jedrc_armasm_format_paragraph() {
    jedrc_format_paragraph("; ");
}
define jedrc_ps_format_paragraph() {
    jedrc_format_paragraph("% ");
}
define jedrc_perl_format_paragraph() {
    jedrc_format_paragraph("# ");
}
define jedrc_lisp_format_paragraph() {
    jedrc_format_paragraph(";; ");
}

define jedrc_text_parsep() {
    return jedrc_parsep("");
}

$1 = "text";
!if (keymap_p($1)) make_keymap($1);
definekey("jedrc_text_format_paragraph", "\eQ", $1);
define text_mode_hook() {
    variable buf;
    use_keymap("text");
    buf = whatbuf();
    !if (jedrc_have_timberc == 0 or
         (strcmp(".article", substr(buf, 1, 8)) and
          strcmp(".letter", substr(buf, 1, 7)))) {
        use_syntax_table("TimberC");
#ifexists use_dfa_syntax
	use_dfa_syntax(1);
#endif
    }
    set_buffer_hook("par_sep", "jedrc_text_parsep");
    runhooks("jedrc_text_mode_hook");
}

define halibut_mode_hook() {
    variable keymap;
    keymap = what_keymap();
    definekey("jedrc_text_format_paragraph", "^[Q", keymap);
    definekey("jedrc_text_format_paragraph", "^[q", keymap);
}

%}}}
%{{{ M-x cvs-* and svn-*

define cvssvn_which(dir) {
    if (file_status(dir + ".svn") == 2)
	return "svn";
    if (file_status(dir + "CVS") == 2)
	return "cvs";
    return 0;
}

define cvssvn_log() {
    variable file, dir, name, which;
    (file, dir, name, ) = getbuf_info();
    if (strcmp(substr(name, 1, 10), "*cvs-log*:") == 0 or
	strcmp(substr(name, 1, 10), "*svn-log*:") == 0) {
        message("This is already a log buffer\n");
        return;
    }
    if (strcmp(substr(name, 1, 15), "*cvs-annotate*:") == 0 or
        strcmp(substr(name, 1, 15), "*svn-annotate*:") == 0) {
        name = substr(name, 16, -1);
    }
    if (strcmp(substr(name, 1, 11), "*cvs-diff*:") == 0 or
        strcmp(substr(name, 1, 11), "*svn-diff*:") == 0) {
        name = substr(name, 12, -1);
    }
    if (strcmp(file, "") == 0) {
        ERROR_BLOCK { error("Unable to determine base file name"); }
        file = get_blocal_var("cvssvn-file");
    }
    if (blocal_var_exists("cvssvn-which")) {
	which = get_blocal_var("cvssvn-which");
    } else {
	which = cvssvn_which(dir);
	jedrc_create_blocal_var("cvssvn-which", 's');
	set_blocal_var(which, "cvssvn-which");
    }
    if (which == "") {
	error("Unable to find an applicable version control tool");
    }
    name = "*" + which + "-log*:" + name;
    change_default_dir(dir);
    sw2buf(name);
    erase_buffer();
    text_mode();
    if (which == "cvs") {
	run_shell_cmd("cvs log " + file);
    } else { % svn
	run_shell_cmd("svnlog " + file + " || svn log -v " + file);
    }
    setbuf_info((getbuf_info & ~1) | 8); % clear modified bit, set readonly
    bob();
    if (which == "cvs") {
	bol_fsearch("-----");
    }
    recenter(1);
    jedrc_create_blocal_var("cvssvn-file", 's');
    set_blocal_var(file, "cvssvn-file");
}
define cvssvn_diff() {
    variable file, dir, name, bufname, bufnum, which, rev1, rev2, dr1, args;
    (file, dir, name, ) = getbuf_info();
    if (strcmp(substr(name, 1, 10), "*cvs-log*:") == 0 or
	strcmp(substr(name, 1, 10), "*svn-log*:") == 0) {
        name = substr(name, 11, -1);
    }
    if (strcmp(substr(name, 1, 15), "*cvs-annotate*:") == 0 or
        strcmp(substr(name, 1, 15), "*svn-annotate*:") == 0) {
        name = substr(name, 16, -1);
    }
    % Unlike log and annotate, it's perfectly meaningful to do a
    % second diff starting from a diff buffer, because diffs are
    % parametrised.
    if (strcmp(substr(name, 1, 11), "*cvs-diff*:") == 0 or
        strcmp(substr(name, 1, 11), "*svn-diff*:") == 0) {
        name = substr(name, 12, -1);
    }
    if (strcmp(file, "") == 0) {
        ERROR_BLOCK { error("Unable to determine base file name"); }
        file = get_blocal_var("cvssvn-file");
    }
    if (blocal_var_exists("cvssvn-which")) {
	which = get_blocal_var("cvssvn-which");
    } else {
	which = cvssvn_which(dir);
	jedrc_create_blocal_var("cvssvn-which", 's');
	set_blocal_var(which, "cvssvn-which");
    }
    if (which == "") {
	error("Unable to find an applicable version control tool");
    }
    rev2 = read_mini ("Later revision: (default: working copy)", "", "");
    if (rev2 != "" and strtrim(rev2, "0123456789") == "") {
        % rev2 is numeric, so default to the previous revision as rev1.
        dr1 = sprintf("%d", integer(rev2) - 1);
        rev1 = read_mini ("Earlier revision:", dr1, "");
    } else {
        rev1 = read_mini ("Earlier revision: (default: current)", "", "");
    }
    bufname = "*" + which + "-diff*:" + name;
    bufnum = 0;
    while (bufferp(bufname)) {
        bufnum++;
        bufname = sprintf("*%s-diff-%d*:%s", which, bufnum, name);
    }
    change_default_dir(dir);
    sw2buf(bufname);
    erase_buffer();
    text_mode();
    if (which == "cvs") {
        args = "";
        if (rev1 == "")
            rev1 = "BASE";
        args = args + " -r" + rev1;
        if (rev2 != "")
            args = args + " -r" + rev2;
	run_shell_cmd("cvs diff" + args + " " + file);
	message("cvs diff" + args + " " + file);
    } else { % svn
        args = "";
        if (rev1 == "")
            rev1 = "BASE";
        if (rev2 != "")
            args = args + " -r" + rev1 + ":" + rev2;
        else
            args = args + " -r" + rev1;
	run_shell_cmd("svn diff" + args + " " + file);
    }
    setbuf_info((getbuf_info & ~1) | 8); % clear modified bit, set readonly
    bob();
    jedrc_create_blocal_var("cvssvn-file", 's');
    set_blocal_var(file, "cvssvn-file");
}
define cvssvn_annotate() {
    variable file, dir, name, line, ret, which;
    (file, dir, name, ) = getbuf_info();
    line = what_line();
    if (strcmp(substr(name, 1, 15), "*cvs-annotate*:") == 0 or
	strcmp(substr(name, 1, 15), "*svn-annotate*:") == 0) {
        message("This is already an annotation buffer\n");
        return;
    }
    if (strcmp(substr(name, 1, 10), "*cvs-log*:") == 0 or
	strcmp(substr(name, 1, 10), "*svn-log*:") == 0) {
        name = substr(name, 11, -1);
    }
    if (strcmp(substr(name, 1, 11), "*cvs-diff*:") == 0 or
        strcmp(substr(name, 1, 11), "*svn-diff*:") == 0) {
        name = substr(name, 12, -1);
    }
    if (strcmp(file, "") == 0) {
        ERROR_BLOCK { error("Unable to determine base file name"); }
        file = get_blocal_var("cvssvn-file");
    }
    if (blocal_var_exists("cvssvn-which")) {
	which = get_blocal_var("cvssvn-which");
    } else {
	which = cvssvn_which(dir);
	jedrc_create_blocal_var("cvssvn-which", 's');
	set_blocal_var(which, "cvssvn-which");
    }
    if (which == "") {
	error("Unable to find an applicable version control tool");
    }
    name = "*" + which + "-annotate*:" + name;
    change_default_dir(dir);
    sw2buf(name);
    text_mode();
    erase_buffer();
    if (which == "cvs") {
	ret = run_shell_cmd("cvs-annotate 2>/dev/null " + file);
	if (ret > 0) {
	    erase_buffer();
	    ret = run_shell_cmd("cvs annotate " + file);
	}
    } else {
	ret = run_shell_cmd("svn-blame 2>/dev/null " + file);
	if (ret > 0) {
	    erase_buffer();
	    ret = run_shell_cmd("svn blame " + file);
	}
    }
    setbuf_info((getbuf_info & ~1) | 8); % clear modified bit, set readonly
    goto_line(line);
    recenter(0);
    jedrc_create_blocal_var("cvssvn-file", 's');
    set_blocal_var(file, "cvssvn-file");
}

define cvs_log() { cvssvn_log(); }
define cvs_annotate() { cvssvn_annotate(); }
define cvs_diff() { cvssvn_diff(); }
define svn_log() { cvssvn_log(); }
define svn_annotate() { cvssvn_annotate(); }
define svn_diff() { cvssvn_diff(); }
define svn_blame() { cvssvn_annotate(); }
define svn_praise() { cvssvn_annotate(); }

add_completion("cvs_log");
add_completion("cvs_annotate");
add_completion("cvs_diff");
add_completion("svn_log");
add_completion("svn_blame");
add_completion("svn_diff");

%}}}
%{{{ M-x rot13

#ifexists TRANSLATE_ARRAY
variable jedrc_rot13_string = char(255);
for ($1 = 1; $1 < 65; $1++) jedrc_rot13_string += char($1);
for ($1 = 0; $1 < 26; $1++) jedrc_rot13_string += char(65+((13+$1) mod 26));
for ($1 = 91; $1 < 97; $1++) jedrc_rot13_string += char($1);
for ($1 = 0; $1 < 26; $1++) jedrc_rot13_string += char(97+((13+$1) mod 26));
for ($1 = 123; $1 < 255; $1++) jedrc_rot13_string += char($1);
define rot13() {
    % Apparently we can only initialise a char array from a string, and
    % S-Lang strings can't contain NULs; so we are unable to construct
    % TRANSLATE_ARRAY in such a way that it is happy with NULs. :-((
    init_char_array(TRANSLATE_ARRAY, jedrc_rot13_string);
    translate_region ();
}
#else
variable jedrc_rot13_array = String_Type[256];
for ($1 = 0; $1 < 256; $1++) {
    $2 = $1;
    if ($2 >= 65 and $2 < 65+26) $2 = 65 + ($2+13-65) mod 26;
    if ($2 >= 97 and $2 < 97+26) $2 = 97 + ($2+13-97) mod 26;
    jedrc_rot13_array[$1] = char($2);
}

define rot13() {
    translate_region (jedrc_rot13_array);
}
#endif
add_completion("rot13");

%}}}
%{{{ M-x start-of-region

% Occasionally handy when defining macros: this puts the cursor at
% the start of the current selection region, by either exchanging
% POINT and MARK or doing nothing. This allows, for example, the
% convenient definition of a macro which wraps the selected region
% in an HTML tag <foo>...</foo>.
define start_of_region() {
    variable l1, c1, l2, c2;

    l1 = what_line();
    c1 = what_column();
    exchange_point_and_mark();
    l2 = what_line();
    c2 = what_column();
    if (l2 > l1 or (l2 == l1 and c2 > c1)) {
	exchange_point_and_mark();
    }
}
add_completion("start_of_region");

%}}}
%{{{ Standard exit hook to allow multiple exit hook registrations

% This is a generally useful exit hook. On an attempt to exit Jed,
% it calls `eval' on the string variable `exit_hook_code'. If this calls
% error() at any point then exit will be abandoned. This allows multiple
% exit hooks to be registered by appending them to the string.
variable sgtatham_exit_hook = 1; % flag it as defined
variable exit_hook_code = ".";
define exit_hook() {
    eval(exit_hook_code);
}

%}}}
%{{{ the pathologically clean-minded M-x polish, which clears *scratch*
define polish() {
    variable buf = whatbuf();
    sw2buf("*scratch*");
    setbuf_info(getbuf_info() &~ 1);
    delbuf("*scratch*");
    sw2buf("*scratch*");
    setbuf_info(getbuf_info() &~ 1);
    sw2buf(buf);
}
%}}}
%{{{ Include local hacks if possible
$1 = expand_filename("~/.jedrc2");
if (file_status($1) == 1) () = evalfile($1);
%}}}
