#!/usr/bin/env python

# bob-deliver: deliver the output of a bob build to a distribution
# point such as a website.
#
# The aim of bob-deliver is to get two apparently contradictory
# benefits:
#
#  (a) if you're doing regular automated builds, it's better to do
#      them regularly rather than only on a code change, because that
#      way if any infrastructure change breaks the build then you find
#      out about it while you can still remember what you just changed.
#
#  (b) if you don't make code changes as often as your automated build
#      happens, then the output files generated by your build will
#      typically not be identical (because tar files, zip files,
#      Windows executables etc all vary in trivial ways like
#      timestamps) and people will complain because they get
#      suspicious of malware and attacks when the md5sum changes on
#      what ought to be the same version of a file.
#
# (b) is obviously solved by doing builds only on a code change, but
# that hurts (a).
#
# bob-deliver tries to solve this problem by containing a means of
# comparing files while disregarding the ways in which they can be
# expected to vary as a result of repeating the same build. So it
# normalises timestamps, ordering of tar and zip file members, etc,
# but still compares the rest of the data exactly.
#
# The typical usage is to ask bob-deliver to deliver from a source
# directory (output from bob itself), to a destination, _via_ an
# intermediate directory. bob-deliver will start by checking the
# .bob_ver file left in the build output directory by bob, to see if
# this is an entirely new build. If it is, it'll copy it into both the
# via and destination directories (first wiping out any previously
# delivered files in the destination); otherwise it will leave the
# destination alone and just compare the source and via dirs, so you
# can check that your build has still generated essentially identical
# output (and hence know if you accidentally break it) without
# disturbing the previously delivered archive of a given software
# version.
#
# If such a comparison fails, bob-deliver can report it by email. If
# you investigate and find a build problem, then you just fix it and
# hopefully the next build will match the via directory again; if the
# difference is actually expected (e.g. you've upgraded a compiler so
# that the generated binaries really are different) then you can
# manually copy the source directory into the via directory, so that
# subsequent builds will be compared against the new via contents, but
# still the destination dir will be untouched until a build occurs
# with a new .bob_ver.

import sys, os, pwd, errno, struct, gzip, zipfile, StringIO, fnmatch, getopt

# TODO:
#  - we could usefully grow normalisation mechanisms for several more
#    file types
#     * Windows HTML Help (.chm). The Debian package fp-utils contains
#       source for a .chm writer, which might provide enough insight
#       into the file format.
#     * Java class files. Apparently NestedVM builds these with the
#       constants in a nondeterministic order, so normalising them
#       might be nontrivial. The Oracle website documents the format,
#       though, at least:
#       http://docs.oracle.com/javase/specs/jvms/se5.0/html/ClassFile.doc.html
#  - it will probably be useful to have a bob command to append input
#    options to .bob_ver (think VER=/DRELEASE=x.yz and the like)

comparelog = ""
def log(text):
    global comparelog
    comparelog = comparelog + text

def ungzip(data):
    return gzip.GzipFile(fileobj=StringIO.StringIO(data)).read()

def normalised_tar_member(data):
    try:
        size = int(data[124:135], 8) # tar sizes are in octal
    except ValueError:
        return None, None, data
    gross = ((size + 511) & ~511) + 512

    # Blank out the file size (comparing the individual tar members
    # will handle this), the last modification time, and the header
    # checksum, which all conveniently happen to be adjacent.
    data = data[:124] + "X"*32 + data[156:]

    return data[:512],data[512:size+512],data[gross:]

def tar_member_name(header):
    name = header[:100]
    name = name[:name.index("\0")]
    return name

def normalised_tar_members(data):
    ret = {}
    while 1:
        h, m, data = normalised_tar_member(data)
        if h == None:
            break
        n = tar_member_name(h)
        ret[n] = h, m
    return ret, data

def normalised_png(data):
    ret = data[:8]
    data = data[8:]
    while len(data) > 0:
        (clen,) = struct.unpack(">L", data[:4])
        chunk = data[:clen+12] # include chunk length, id and checksum
        data = data[clen+12:]
        if chunk[4:8] == "tIME":
            pass # omit timestamp chunk
        elif chunk[4:13] == "tEXtdate:":
            pass # another kind of timestamp chunk
        else:
            ret = ret + chunk
    return ret

def normalised_winhelp(data):
    def wh_file(data, offset):
        hdr = data[offset:offset+9]
        (flen,) = struct.unpack("<L", hdr[4:8])
        return data[offset+9:offset+9+flen]
    (mdoffset,) = struct.unpack("<L", data[4:8])
    md = wh_file(data, mdoffset) # master directory
    md = md[0x2e:]
    timeoffset = None
    while 1:
        namelen = md.index("\0")
        name = md[:namelen]
        (offset,) = struct.unpack("<L", md[namelen+1:namelen+5])
        md = md[namelen+5:]
        if name == "|SYSTEM":
            timeoffset = offset + 0xF
            break
    if timeoffset != None:
        data = data[:timeoffset] + "XXXX" + data[timeoffset+4:]
    return data

def ends_with(s1,s2):
    return s1[-len(s2):] == s2

def ignored_filename(name):
    if ends_with(name, "/manifest"):
        return 1
    # CHMs are too difficult to compare.
    if ends_with(name, ".chm"):
        return 1
    # So are Java class files.
    if ends_with(name, ".class"):
        return 1
    # Ditto Mac DMGs.
    if ends_with(name, ".dmg"):
        # On the basis that these _should_ just be an archive format
        # that we ought in principle to be able to recurse into
        # (albeit a weird and filesystemish one), I tried to find out
        # the format of these, but what I found didn't match reality.
        #
        # http://en.wikipedia.org/wiki/Apple_Disk_Image says that .dmg
        # files are in UDIF format which starts with the four-byte
        # magic number "2IMG" (or possibly "GMI2" due to endianness),
        # but the first actual .dmg I examined had nothing of the sort
        # and instead its first 47 bytes were all either 0x80, 0x7F or
        # zero. So, for the moment, no idea how to read these.
        return 1
    # And anything that matches a user-supplied pattern.
    for pat in ignored_patterns:
        if fnmatch.fnmatch(os.path.basename(name), pat):
            return 1
    return 0

def is_pe(data):
    if data[:2] != "MZ":
        return 0
    (pe_offset,) = struct.unpack("<L", data[0x3c:0x40])
    if data[pe_offset:pe_offset+2] != "PE":
        return 0
    return 1

def normalised_pe(data):
    (pe_offset,) = struct.unpack("<L", data[0x3c:0x40])
    return data[:pe_offset+8] + "XXXX" + data[pe_offset+12:]

def compare(data1, data2, name1, name2):
    if ignored_filename(name1) and ignored_filename(name2):
        return 0
    if data1[:2] == "\x1f\x8b" and data2[:2] == "\x1f\x8b":
        # Gzip files. Un-gzip them.
        return compare(ungzip(data1), ungzip(data2),
                       name1 + "=>gunzip", name2 + "=>gunzip")

    if data1[257:263] == "ustar " and data2[257:263] == "ustar ":
        # Tar files. Normalise the timestamps, and compare them member
        # by member.
        mems1, trailer1 = normalised_tar_members(data1)
        mems2, trailer2 = normalised_tar_members(data2)
        s1 = set(mems1)
        s2 = set(mems2)
        if s1 != s2:
            log("%s and %s differ in tar file lists\n" % (name1, name2))
            if len(s1 - s2) > 0:
                log("%s: %s\n" % (name1, list(s1-s2)))
            if len(s2 - s1) > 0:
                log("%s: %s\n" % (name2, list(s2-s1)))
            return 1
        for name in mems1:
            h1, m1 = mems1[name]
            h2, m2 = mems2[name]
            if h1 == None and h2 == None:
                break
            if h1 != h2:
                log(("%s and %s differ in tar file header for %s") %
                    (name1, name2, name))
                return 1
            if compare(m1, m2,
                       "%s=>untar=>%s" % (name1, name),
                       "%s=>untar=>%s" % (name2, name)):
                return 1
        if trailer1 != trailer2:
            log("%s and %s differ in tar trailer\n" % (name1, name2))
            return 1
        return 0

    if data1[:4] == "PK\x03\x04" and data2[:4] == "PK\x03\x04":
        # Zip files. Normalise the timestamps and compare member by
        # member.
        zf1 = zipfile.ZipFile(StringIO.StringIO(data1), "r")
        zf2 = zipfile.ZipFile(StringIO.StringIO(data2), "r")
        n1 = zf1.namelist()
        n2 = zf2.namelist()
        n1.sort()
        n2.sort()
        s1 = set(n1)
        s2 = set(n2)
        if s1 != s2:
            log("%s and %s differ in zip file lists\n" % (name1, name2))
            if len(s1 - s2) > 0:
                log("%s: %s\n" % (name1, list(s1-s2)))
            if len(s2 - s1) > 0:
                log("%s: %s\n" % (name2, list(s2-s1)))
            return 1
        for name in n1:
            contents1 = zf1.open(name).read()
            contents2 = zf2.open(name).read()
            if compare(contents1, contents2,
                       "%s=>unzip=>%s" % (name1, name),
                       "%s=>unzip=>%s" % (name2, name)):
                return 1
        return 0

    if data1[:8] == "\x89PNG\x0d\x0a\x1a\x0a" and data2[:8] == "\x89PNG\x0d\x0a\x1a\x0a":
        data1 = normalised_png(data1)
        data2 = normalised_png(data2)
        if data1 != data2:
            log("%s and %s differ in PNG image content\n" % (name1, name2))
            return 1
        return 0

    if data1[:4] == "\x3F\x5F\x03\x00" and data2[:4] == "\x3F\x5F\x03\x00":
        data1 = normalised_winhelp(data1)
        data2 = normalised_winhelp(data2)
        if data1 != data2:
            log("%s and %s differ in Windows Help content\n" % (name1, name2))
            return 1
        return 0

    if is_pe(data1) and is_pe(data2):
        data1 = normalised_pe(data1)
        data2 = normalised_pe(data2)
        if data1 != data2:
            log("%s and %s differ in PE content\n" % (name1, name2))
            return 1
        return 0

    if data1 != data2:
        log("%s and %s differ in content\n" % (name1, name2))
        return 1
    return 0

def contents(topdir, skip=set()):
    class container:
        pass
    c = container()
    c.skip = skip
    c.output = []
    c.topdir = topdir
    c.prefix = topdir+"/"
    c.prefixlen = len(c.prefix)
    def callback(c, directory, files):
        if directory == c.topdir:
            transform = lambda filename: filename
        else:
            assert directory[:c.prefixlen] == c.prefix
            shortdir = directory[c.prefixlen:]
            transform = lambda filename: os.path.join(shortdir,filename)
        files.sort()
        for filename in files:
            f = os.path.join(directory, filename)
            if os.path.isdir(f) and filename not in c.skip:
                c.output.append(transform(filename))
        for filename in files:
            f = os.path.join(directory, filename)
            if os.path.isfile(f) and filename not in c.skip:
                c.output.append(transform(filename))
    os.path.walk(topdir, callback, c)
    return c.output

verbose = False
force_replace = False
ignored_patterns = []
mode = 'copy'
filelist = []
email = None
try:
    opts, args = getopt.gnu_getopt(sys.argv[1:], "vf", [
            "verbose", "only=", "compare", "help", "email=", "force",
            "ignore="
            ])
except getopt.GetoptError as e:
    sys.stderr.write(str(e) + "\n")
    sys.exit(1)

for opt, val in opts:
    if opt == '-v' or opt == '--verbose':
        verbose = True
    elif opt == '-f' or opt == '--force':
        force_replace = True
    elif opt == '--compare':
        mode = 'compare'
    elif opt == '--only':
        filelist.extend(val.split(","))
    elif opt == '--ignore':
        ignored_patterns.append(val)
    elif opt == '--email':
        email = val
    elif opt == '--help':
        sys.stdout.write("""\
  usage: bob-deliver [options] SOURCE VIA DESTINATION
     or: bob-deliver [options] --compare FILE1 FILE2
options: --only FILENAMES      restrict to comma-separated list of files
         --email ADDRESS       send reports of failed comparisons by email
         -v, --verbose         report activity in detail
""")
        sys.exit(0)
    else:
        assert False, "unrecognised option"

if mode == 'compare':
    if len(filelist) > 0:
        sys.stderr.write("option '--only' unexpected in compare mode\n")
        sys.exit(1)
    if len(args) != 2:
        sys.stderr.write("exactly two filenames expected in compare mode\n")
        sys.exit(1)
    with open(args[0]) as f: data0 = f.read()
    with open(args[1]) as f: data1 = f.read()
    ret = compare(data0, data1, args[0], args[1])
    if ret:
        sys.stdout.write(comparelog)
        sys.exit(1)
    else:
        sys.exit(0)

if mode == 'copy':
    if len(args) != 3:
        sys.stderr.write("exactly three directory names expected in copy mode\n")
        sys.exit(1)
    src, via, dst = args

    # The via directory is allowed to start off completely absent.
    if not os.path.isdir(via):
        os.mkdir(via)

    if verbose:
        sys.stderr.write("Delivering from %s via %s to %s\n" %
                         (src, via, dst))

    if force_replace:
        if verbose:
            sys.stderr.write("Delivering new build (command line force)\n")
            replace = True
    else:
        replace = False
        with open(os.path.join(src, ".bob_ver")) as f:
            srcver = f.read()
        try:
            with open(os.path.join(via, ".bob_ver")) as f:
                viaver = f.read()
            if srcver != viaver:
                if verbose:
                    sys.stderr.write("Delivering new build (%s and %s do not match)\n" %
                                     (os.path.join(src, ".bob_ver"),
                                      os.path.join(via, ".bob_ver")))
                replace = True
        except IOError as e:
            if e.errno == errno.ENOENT:
                if verbose:
                    sys.stderr.write("Delivering new build (%s does not exist)\n" %
                                     os.path.join(via, ".bob_ver"))
                replace = True
            else:
                raise

    if replace:
        # Version data has changed; we're replacing everything with a
        # new build. Start by ensuring the destination dir actually
        # exists.
        if not os.path.isdir(dst):
            os.mkdir(dst)

        # Start by deleting everything in the via dir from both there
        # and the dst dir (wiping out the build being replaced, in
        # case its filenames aren't the same as the new stuff).
        for path in reversed(contents(via, set([".bob_ver"]))):
            for thispath in os.path.join(dst, path), os.path.join(via, path):
                try:
                    if os.path.isdir(thispath):
                        if verbose:
                            sys.stderr.write("Removing old delivered directory %s\n" % thispath)
                        os.rmdir(thispath)
                    else:
                        if verbose:
                            sys.stderr.write("Deleting old delivered file %s\n" % thispath)
                        os.remove(thispath)
                except OSError as e:
                    if e.errno == errno.ENOENT:
                        if verbose:
                            sys.stderr.write(" ... not there, continuing\n")
                    else:
                        raise

        # Now copy everything from the src dir into both the via and
        # dst dirs.
        for path in contents(src):
            if len(filelist) > 0 and (path not in filelist and
                                      path != ".bob_ver"):
                continue
            if os.path.isdir(os.path.join(src, path)):
                for dirpath in os.path.join(via, path), os.path.join(dst, path):
                    try:
                        if verbose:
                            sys.stderr.write("Making directory %s\n" % dirpath)
                        os.mkdir(dirpath)
                    except OSError as e:
                        if e.errno == errno.EEXIST:
                            if verbose:
                                sys.stderr.write(" ... already there, " +
                                                 "continuing\n")
                        else:
                            raise
            elif os.path.isfile(os.path.join(src, path)):
                if verbose:
                    sys.stderr.write("Reading %s\n" % os.path.join(src, path))
                with open(os.path.join(src, path)) as f:
                    data = f.read()
                if verbose:
                    sys.stderr.write("Writing %s\n" % os.path.join(via, path))
                with open(os.path.join(via, path), "w") as f:
                    f.write(data)
                if path != ".bob_ver": # this goes in via but not dst
                    if verbose:
                        sys.stderr.write("Writing %s\n" % os.path.join(dst, path))
                    with open(os.path.join(dst, path), "w") as f:
                        f.write(data)

        sys.exit(0) # return success, meaning we've delivered a fresh build

    else:
        # Version data has changed; this ought to be the same build.
        if verbose:
            sys.stderr.write(("Checking against previous build "+
                              "(%s and %s match)\n") %
                             (os.path.join(src, ".bob_ver"),
                              os.path.join(via, ".bob_ver")))

        # Compare src against via, and report if they don't match.
        srcfiles = contents(src, set([".bob_ver"]))
        if len(filelist) > 0:
            srcfiles = [path for path in srcfiles if path in filelist]
        viafiles = contents(via, set([".bob_ver"]))
        if srcfiles != viafiles:
            log("%s and %s differ in file lists\n" % (src, via))
            if len(set(srcfiles) - set(viafiles)) > 0:
                log("%s: %s\n" % (src, sorted(set(srcfiles) - set(viafiles))))
            if len(set(viafiles) - set(srcfiles)) > 0:
                log("%s: %s\n" % (src, sorted(set(viafiles) - set(srcfiles))))

        for path in srcfiles:
            if verbose:
                sys.stderr.write("Comparing %s with %s\n" %
                                 (os.path.join(src, path),
                                  os.path.join(via, path)))

            if os.path.isfile(os.path.join(src, path)):
                with open(os.path.join(src, path)) as f:
                    srcdata = f.read()
            else:
                srcdata = None
            if os.path.isfile(os.path.join(via, path)):
                with open(os.path.join(via, path)) as f:
                    viadata = f.read()
            else:
                viadata = None

            if srcdata is None and viadata is None:
                pass # ok
            elif srcdata is None or viadata is None:
                log("%s and %s do not agree on directory vs file" %
                    (os.path.join(src, path), os.path.join(via, path)))
            else:
                compare(srcdata, viadata,
                        os.path.join(src, path), os.path.join(via, path))

        if len(comparelog) > 0:
            report = ("Comparison of %s with %s failed\n%s" %
                      (src, via, comparelog))
            if email is None:
                sys.stderr.write(report)
            else:
                email = """\
From: bob-deliver <%s>
To: <%s>
Subject: Build compare failed: %s

bob-deliver suffered a build comparison failure
Delivery from: %s
Delivery via:  %s
Delivery to:   %s

%s""" % (pwd.getpwuid(os.getuid())[0], # From
         email, # To
         src, # src dir in subject line
         src, # src dir in first para
         via, # via dir in first para
         dst, # dst dir in first para
         comparelog)
                with os.popen("/usr/lib/sendmail -oem -t -oi", "w") as f:
                    f.write(email)

        sys.exit(1) # return failure, meaning there is no new build
