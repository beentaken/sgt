#!/usr/bin/env python

import sys
import os
import tempfile
import string
import re
import time
import ljproto

# Here's the TODO list for potential future enhancements.
#
#  - It'd be quite nice to be able to specify {t stuff} inside the
#    explicit {mbreak} text, in case the simple (part N) suffix
#    isn't sufficient.
#
#  - Support for friends-only, specific-friend-group, and private
#    entries (uncertain when if ever the first two will be useful,
#    but the latter will be handy for testing purposes)
#
#  - IWBNI we could do something _configurable_ with the Mono text
#    instead of the current double-play of shoving it in diary.data
#    and throwing it through xcopy.
#
#  - Completely silly feature: editor brackets [Like this. --Ed]
#    which would look better in italics where that's available.
#     * Uncertain whether this should be a specialist feature {ed
#       Oi!} or a generic weak-italics feature {wi [Oi! --Ed]}. Or
#       both, I suppose.
#
#  - Handling of people's names?
#     * can use <lj user="simont"> in HTML.
#     * bolded mono account names on Mono?
#     * have to be able to specify a single name and have both
#       formats Just Work, including sensible handling of
#       situations where one or both media don't have a native
#       format for the name.
#     * usually I'd want to use this once and then refer to the
#       person by their ordinary name after that. Hmmm.
#     * This may well be far far too much work to bother with.
#
#  - Once I used a separating rule (centred ----*-*---- sort of
#    thing) to delimit disconnected bits of a single entry. Didn't
#    actually look all that good the way I did it, but if I ever
#    need it again I should think up a way to do it. (Not sure how
#    it'd work in HTML, though; <hr> is much too wide.)

# Utility routines.
def isint(s):
    try:
	n = int(s)
	return 1
    except ValueError:
	return 0

# Paragraph states are:
#  - PNORMAL is a normal wrapped paragraph.
#  - PPRE is a preformatted paragraph (<pre> in HTML).
#  - PBULLET is a bulletted paragraph.
#  - PMBREAK is a mono-break paragraph.
#  - PTITLE is a title paragraph.
#  - PTITLEQUIET is a quiet title paragraph (appears in the title
#    on title-using systems, but is formatted normally on Mono).
#  - PTITLEONLY is a title paragraph which _only_ appears in
#    title-using systems.
#  - PTALKER is a talker-formatted paragraph.
PNORMAL = 1
PPRE = 2
PBULLET = 3
PMBREAK = 4
PTITLE = 5
PTITLEQUIET = 6
PTITLEONLY = 7
PTALKER = 8
def is_title(typ): return typ in [PTITLE,PTITLEQUIET,PTITLEONLY]
# Mono attribute definitions.
mono_colours = "AAAAAAAAKRGYBMCW" # 0-7 normal, 8-15 coloured
ATTR_BOLD = 1
ATTR_UNDER = 2
ATTR_FG = 0xF0
ATTR_FGSHIFT = 4
ATTR_FOOTNOTE = 0x90
ATTR_QUOTED = 0xB0
ATTR_STORY = 0xA0
ATTR_URL = 0xC3
# Mono (text,attr,break) combinations for quote prefixes and
# story-mode text.
monoquotes = [("", 0, 0), ("  ", ATTR_QUOTED, 0),
("> ", ATTR_QUOTED, 0), ("   ", ATTR_STORY, 0)]
# Same for news.
newsquotes = [("", 0), ("  ", 0), ("> ", 0), ("   ", 0)]
# Regexp matching dangerous things to put at the start of a line.
monodanger = re.compile(r'^[A-Z][A-Za-z]*:')
# Maximum length of a Mono edit.
MONO_EDIT_MAX = 98
class output:
    def __init__(self):
	self.mono = []
	self.news = []
	self.html = ""
	self.subj = ""
	self.newssubj = ""
	self.quotestate = 0
        self.monoquote = monoquotes[0]
        self.newsquote = newsquotes[0]
	self.in_ul = 0
        self.timestamp = now
	self.mono_last_edit_start = -1
	self.mono_edit_count = 0
        self.mono_new_edit()
        self.mono_bullet_wid = 0
	self.mono_bullet_txt = ""
	self.warnings = []
	self.mono_title = []
	pass

    def mono_blankline(self):
        if len(self.mono) > 0 and self.mono[-1] != "":
            self.mono.append("")

    def news_blankline(self):
        if len(self.news) > 0 and self.news[-1] != "":
            self.news.append("")

    def mono_new_edit(self):
        lt = time.localtime(self.timestamp)
        self.timestamp = self.timestamp + 1
        self.mono_blankline()
	if len(self.mono) - self.mono_last_edit_start >= MONO_EDIT_MAX:
	    msg = "Mono edit at line %d is too long!" % (self.mono_last_edit_start+1)
	    self.warnings.append(msg)
	self.mono_last_edit_start = len(self.mono)
        msgline = "Message: %08X" % self.timestamp
        msgline = msgline + " " * 23
        msgline = msgline + time.strftime("(%a %b %e %H:%M:%S %Y)", lt)
        self.mono.append(msgline)
        self.mono.append("\031") # ^Y means paste in nameline
        self.mono.append("")
	self.mono_edit_count = self.mono_edit_count + 1

    def warn(msg):
	self.warnings.append(msg)

    def mono_add_word(self, text, attrs, isbreak):
        self.mono_words.append((text, attrs, isbreak))

    def news_add_word(self, text, isbreak):
        self.news_words.append((text, isbreak))

    def mono_append(self, attr, currwid, word):
        text = word[0]
        sw = len(text)
        if (word[1] & ATTR_FG) != (attr & ATTR_FG):
            text = "\007C" + \
            mono_colours[(word[1] & ATTR_FG) >> ATTR_FGSHIFT] + text
        if (word[1] & ATTR_UNDER) != (attr & ATTR_UNDER):
            text = ["\007u","\007U"][(word[1] & ATTR_UNDER) != 0] + text
        if (word[1] & ATTR_BOLD) != (attr & ATTR_BOLD):
            text = ["\007b","\007B"][(word[1] & ATTR_BOLD) != 0] + text
	# Mono `feature'. If the first thing on a line is a capital
	# letter, followed by some number of capital and small
	# letters, followed by a colon, it will be indented by one
	# unless we prefix it with a ]a trib.
	if currwid == 0 and monodanger.search(text):
	    text = "\007a" + text
        return word[1], len(text), sw, text

    def mono_wrap_optimal(self, list, i1, i2, width=79, opt_width=72):
        class holder:
	    "container class"
	    pass
        n = len(list)
        z = []
        for i in range(n-1, -1, -1):
            if i == 0:
                attr, realwid, scrwid, text = self.mono_append(0, 0, i1)
            else:
                attr, realwid, scrwid, text = self.mono_append(0, 0, i2)
	    best = None
	    bestcost = None
	    z = [holder()] + z
	    for j in range(1, n-i+1):
                attr, rw, sw, text = self.mono_append(attr,realwid,list[i+j-1])
                realwid = realwid + rw
                scrwid = scrwid + sw
                if i+j < n and list[i+j][2] == 0:
                    continue # can't wrap here; don't bother trying
	        if realwid > width:
		    break
	        if j >= len(z):
		    if scrwid <= opt_width:
		        # We allow the last line to be short without
		        # penalty, although we still penalise it for being
		        # longer than opt_width.
		        cost = 0
		    else:
		        cost = (opt_width-scrwid) ** 2
	        else:
		    thiscost = (opt_width-scrwid) ** 2
		    cost = thiscost + z[j].cost
	        if bestcost == None or bestcost >= cost:
		    bestcost = cost
		    best = j
	    if best == None:
	        z[0].cost = 0
	        z[0].n = n - i
	    else:
	        z[0].cost = bestcost
	        z[0].n = best
        i = 0
        ret = []
        while i < len(list):
	    n = z[i].n
            if i == 0:
                attr, rw, sw, text = self.mono_append(0, 0, i1)
            else:
                attr, rw, sw, text = self.mono_append(0, 0, i2)
            for word in list[i:i+n]:
                attr, rwi, sw, extratext = self.mono_append(attr, rw, word)
		rw = rw + rwi
                text = text + extratext
            ret.append(text)
	    i = i + n
            if i < len(list) and list[i][2] == 1:
                i = i + 1
        return ret

    def news_wrap_optimal(self, list, i1, i2, width=72, opt_width=72):
        class holder:
	    "container class"
	    pass
        n = len(list)
        z = []
        for i in range(n-1, -1, -1):
            if i == 0:
		text = i1[0]
	    else:
		text = i2[0]
	    wid = len(text)
	    best = None
	    bestcost = None
	    z = [holder()] + z
	    for j in range(1, n-i+1):
		text = text + list[i+j-1][0]
		wid = len(text)
                if i+j < n and list[i+j][1] == 0:
                    continue # can't wrap here; don't bother trying
	        if wid > width:
		    break
	        if j >= len(z):
		    if wid <= opt_width:
		        # We allow the last line to be short without
		        # penalty, although we still penalise it for being
		        # longer than opt_width.
		        cost = 0
		    else:
		        cost = (opt_width-wid) ** 2
	        else:
		    thiscost = (opt_width-wid) ** 2
		    cost = thiscost + z[j].cost
	        if bestcost == None or bestcost >= cost:
		    bestcost = cost
		    best = j
	    if best == None:
	        z[0].cost = 0
	        z[0].n = n - i
	    else:
	        z[0].cost = bestcost
	        z[0].n = best
        i = 0
        ret = []
        while i < len(list):
	    n = z[i].n
            if i == 0:
		text = i1[0]
            else:
		text = i2[0]
            for word in list[i:i+n]:
		text = text + word[0]
            ret.append(text)
	    i = i + n
            if i < len(list) and list[i][1] == 1:
                i = i + 1
        return ret

    def mono_show_para(self, blankable=0):
        quot = self.monoquote
        if self.mono_bullet_wid:
	    if self.mono_bullet_txt != "":
		i1 = (quot[0] + self.mono_bullet_txt, quot[1], quot[2])
		i2 = (quot[0] + " " * self.mono_bullet_wid, quot[1], quot[2])
	    else:
		i1 = i2 = (quot[0] + " " * self.mono_bullet_wid, quot[1], quot[2])
        else:
            i1 = i2 = quot
        list = self.mono_wrap_optimal(self.mono_words, i1, i2)
	if blankable and len(list) == 0:
	    list = ['']
        self.mono.extend(list)

    def news_show_para(self, blankable=0):
        quot = self.newsquote
        if self.news_bullet_wid:
	    if self.news_bullet_txt != "":
		i1 = (quot[0] + self.news_bullet_txt, quot[1])
		i2 = (quot[0] + " " * self.news_bullet_wid, quot[1])
	    else:
		i1 = i2 = (quot[0] + " " * self.news_bullet_wid, quot[1])
        else:
            i1 = i2 = quot
        list = self.news_wrap_optimal(self.news_words, i1, i2)
	if blankable and len(list) == 0:
	    list = ['']
        self.news.extend(list)

    def htmlsafe(self, text):
	text = string.replace(text, "&", "&amp;")
	text = string.replace(text, "...", "&#8230;")
	text = string.replace(text, "<", "&lt;")
	text = string.replace(text, ">", "&gt;")
	text = string.replace(text, "\"", "&quot;")
	return text

    def quote_state(self, n):
	if self.quotestate != n:
	    if self.quotestate == 1 or self.quotestate == 2:
		self.html = self.html + "</blockquote>"
	    elif self.quotestate == 3:
		self.html = self.html + "</span>"
	    if n == 1:
		self.html = self.html + "<blockquote style=\"padding-left: 1.2em; margin-left: 1em\">"
	    elif n == 2:
		self.html = self.html + "<blockquote style=\"border-left: 0.2em solid; padding-left: 1em; margin-left: 1em\">"
	    elif n == 3:
		self.html = self.html + "<span class=\"fiction\">"
	    self.quotestate = n
            self.monoquote = monoquotes[n]
            self.newsquote = newsquotes[n]

    def ljcut(self, text):
	if text == None:
	    self.html = self.html + "</lj-cut>"
	elif text == []:
	    self.html = self.html + "<lj-cut>"
	else:
	    strtext = ""
	    for i in text:
		if i[0] == WORD or i[0] == WHITE:
		    strtext = strtext + i[1]
		elif i[0] == NL:
		    strtext = strtext + " "
	    self.html = self.html + "<lj-cut text=\"" + self.htmlsafe(strtext) + "\">"

    def finish(self):
	# Strip off a trailing </p>, which is not required by LJ
	# and occasionally messes things up.
	if self.html[-4:] == "</p>":
	    self.html = self.html[:-4]

	# Switch round <lj-cut> and <p> tags.
	i = -1
	try:
	    while 1:
		i = string.index(self.html, "<lj-cut", i+1)
		# Failure to find this will throw ValueError and
		# terminate the while loop. Ick, but it'll work.
		j = string.index(self.html, ">", i)
		if self.html[j+1:j+4] == "<p>":
		    self.html = self.html[:i] + "<p>" + \
		    self.html[i:j+1] + self.html[j+4:]
	except ValueError, e:
	    pass

	# Remove all empty <p></p>.
	i = -1
	try:
	    while 1:
		i = string.index(self.html, "<p></p>", i+1)
		# Failure to find this will throw ValueError and
		# terminate the while loop. Ick, but it'll work.
		self.html = self.html[:i] + self.html[i+7:]
		i = i - 1
	except ValueError, e:
	    pass

	self.mono_blankline()
	self.news_blankline()
	if len(self.mono) - self.mono_last_edit_start >= MONO_EDIT_MAX:
	    msg = "Mono edit at line %d is too long!" % (self.mono_last_edit_start+1)
	    self.warnings.append(msg)

	for i in range(len(self.mono)):
	    if len(self.mono[i]) > 79:
		msg = "Mono line %d is too long!" % i
		self.warnings.append(msg)

	global nowlocal
	self.news_headers = ["Newsgroups: chiark.journals"]
	self.news_headers.append("Date: " + time.strftime("%a, %d %b %Y %H:%M:%S %z", nowlocal))
	# FIXME: name and subject prefix ought to be better than hardcoded.
	self.news_headers.append("From: Simon Tatham <anakin@pobox.com>")
	self.news_headers.append("Subject: [sgtatham] " + self.newssubj)
	self.news = self.news_headers + [""] + self.news
	# FIXME: likewise sig.
	self.news.append("-- ")
	self.news.append("Simon Tatham's multi-format journal, also available at:")
	self.news.append(" - http://www.livejournal.com/users/simont/")
	self.news.append(" - <MLNANAKIN!> on mono.org")

    def begin_para(self, typ):
	self.html_ok = 1
	self.mono_ok = 1
	self.news_ok = 1
	self.html_title = 0
        self.mono_attr = self.monoquote[1]
        self.mono_bullet_wid = 0
	self.mono_bullet_txt = ""
        self.news_bullet_wid = 0
	self.news_bullet_txt = ""
	self.para_type = typ

	if typ == PBULLET:
	    if not self.in_ul: self.html = self.html + "<ul>"
	    self.html = self.html + "<li>"
	    self.in_ul = 1
            self.mono_bullet_wid = 3
	    self.mono_bullet_txt = " - "
            self.news_bullet_wid = 3
	    self.news_bullet_txt = " - "
	else:
	    if self.in_ul: self.html = self.html + "</ul>"
	    self.in_ul = 0

	if typ == PPRE:
	    self.html = self.html + "<pre><code>"
	if typ == PMBREAK:
	    self.html_ok = self.news_ok = 0
            self.mono_new_edit()
	if is_title(typ):
	    self.html_ok = 0
	    self.html_title = 1
	    if typ == PTITLE:
		self.mono_attr = self.mono_attr | ATTR_UNDER
	    elif typ == PTITLEONLY:
		self.mono_ok = 0
	if typ == PNORMAL:
	    self.html = self.html + "<p>"
	if typ == PTALKER:
	    self.html = self.html + "<table cellspacing=\"0\" cellpadding="
	    self.html = self.html + "\"0\" border=\"0\">"
	    self.talker = 0 # no <tr> open, no <td> open

        self.mono_words = []
        self.news_words = []

    def end_para(self, typ):
        bullet = 0
	if typ == PPRE:
	    self.html = self.html + "</code></pre>"
	if typ == PNORMAL:
	    self.html = self.html + "</p>"
	if typ == PBULLET:
	    self.html = self.html + "</li>"
	if typ == PTITLE:
	    self.mono_title = self.mono_words
	if is_title(typ):
	    self.newssubj = ""
	    for word in self.news_words:
		self.newssubj = self.newssubj + word[0]
	    newsshow = 0
	else:
	    newsshow = 1
	if typ == PTALKER:
	    if (self.talker & 2):
		self.html = self.html + "</td>"
	    if (self.talker & 1):
		self.html = self.html + "</tr>"
	    self.html = self.html + "</table>"
        self.mono_show_para()
        self.mono_blankline()
	if newsshow:
	    self.news_show_para()
	    self.news_blankline()

    def tlbegin(self):
	self.htmlsave = self.html
	self.html = ""
	if len(self.mono_words) > 0:
	    self.mono_show_para()
	    self.mono_words = []
	if len(self.news_words) > 0:
	    self.news_show_para()
	    self.news_words = []
	pass

    def tlend(self):
	if self.html_ok:
	    text = self.html
	    self.html = self.htmlsave
	    if (self.talker & 2):
		self.html = self.html + "</td>"
	    if (self.talker & 1):
		self.html = self.html + "</tr>"
	    self.html = self.html + "<tr valign=\"top\">"
	    self.html = self.html + "<td width=\"100\" align=\"right\">"
	    self.html = self.html + "<b>" + text + "</b>&nbsp;</td><td>"
	    self.talker |= 3
	if self.mono_ok:
	    text = ""
	    attr = sw = 0
	    for word in self.mono_words:
		w2 = (word[0], word[1] | ATTR_BOLD) + word[2:]
                attr, rwi, swi, extratext = self.mono_append(attr, 0, w2)
		sw = sw + swi
                text = text + extratext
	    attr, rwi, swi, extratext = self.mono_append(attr, 0, (" ",0,0))
	    sw = sw + swi
	    text = text + extratext
	    left = 10 - sw
	    if left < 0: left = 0
	    self.mono_words = []
	    self.mono_bullet_txt = " " * left + text
	    self.mono_bullet_wid = left + sw
	if self.news_ok:
	    text = ""
	    attr = sw = 0
	    for word in self.news_words:
		text = text + word[0]
	    text = text + " "
	    left = 10 - len(text)
	    if left < 0: left = 0
	    self.news_words = []
	    self.news_bullet_txt = " " * left + text
	    self.news_bullet_wid = left + len(text)

    def tb(self):
	if self.html_ok:
	    if (self.talker & 2):
		self.html = self.html + "</td>"
	    if (self.talker & 1):
		self.html = self.html + "</tr>"
	    self.html = self.html + "<tr><td>&nbsp;</td></tr>"
	    self.talker &= ~3
	if self.mono_ok:
	    if len(self.mono_words) > 0:
		self.mono_show_para()
		self.mono_words = []
	if self.news_ok:
	    if len(self.news_words) > 0:
		self.news_show_para()
		self.news_words = []

    def footnote(self, text):
	if self.html_ok:
	    self.html = self.html + "<span style=\"color: red\">["+text+"]</span>"
        if self.mono_ok:
            self.mono_add_word("["+text+"]", ATTR_FOOTNOTE, 0)
        if self.news_ok:
            self.news_add_word("["+text+"]", 0)

    def line_break(self):
	if self.html_ok:
	    self.html = self.html + "<br>"
        if self.mono_ok:
            self.mono_show_para(1)
            self.mono_words = []
        if self.news_ok:
            self.news_show_para(1)
            self.news_words = []

    def quote(self, opening):
	if self.html_ok:
	    self.html = self.html + ["&#8217;","&#8216;"][opening != 0]
	elif self.html_title:
	    self.subj = self.subj + ["&#8217;","&#8216;"][opening != 0]
	# Special case: in talker paragraphs, all quotes are '.
	if self.para_type == PTALKER:
	    quotes = ["'","'"]
	else:
	    quotes = ["'","`"]
        self.mono_add_word(quotes[opening != 0], self.mono_attr, 0)
        self.news_add_word(quotes[opening != 0], 0)
        # '

    def emph(self, on):
	if self.html_ok:
	    self.html = self.html + ["</em>","<em>"][on != 0]
	elif self.html_title:
	    self.subj = self.subj + ["</em>","<em>"][on != 0]
        self.mono_add_word("_", self.mono_attr, 0)
        self.news_add_word("_", 0)

    def code(self, on):
	if self.html_ok:
	    self.html = self.html + ["</code>","<code>"][on != 0]
	elif self.html_title:
	    self.subj = self.subj + ["</code>","<code>"][on != 0]
	if on:
            self.mono_attr = self.mono_attr | ATTR_QUOTED
	else:
            self.mono_attr = self.mono_attr & ~ATTR_FG

    def bold(self, on):
	if self.html_ok:
	    self.html = self.html + ["</b>","<b>"][on != 0]
	elif self.html_title:
	    self.subj = self.subj + ["</b>","<b>"][on != 0]

	if on:
            self.mono_attr = self.mono_attr | ATTR_BOLD
	else:
            self.mono_attr = self.mono_attr & ~ATTR_BOLD

	if self.news_ok:
	    self.news_add_word("*", 0)

    def url(self, text, inline, image):
	utext = text
	if image:
	    inline = 0
	if string.find(utext, ":") < 0:
	    if string.find(utext, "/") < 0:
		utext = utext + "/"
	    utext = "http://" + utext
	if self.html_ok:
	    if image:
		self.html = self.html + "</p><p align=\"center\"><a href=\"" \
		+ utext + "\"><img border=0 src=\"" + utext + "\"></a></p><p>"
	    else:
		self.html = self.html + "<a href=\"" + utext + "\">" + self.htmlsafe(text) + "</a>"
	elif self.html_title:
	    self.subj = self.subj + "<a href=\"" + utext + "\">" + self.htmlsafe(text) + "</a>"
	if not inline:
	    self.mono_show_para()
	    if self.mono_bullet_wid:
		self.mono_bullet_txt = ""
	    self.mono_blankline()

	    newstext = text

	    attrs = "\007B\007U\007CB"
	    maxlen = 79 - len(attrs)
	    totallen = len(text)
	    while len(text) > 0:
		currtext = text[:maxlen]
		text = text[maxlen:]
		monotext = attrs + currtext
		spaces = (72 - totallen) / 2
		if spaces > 79 - len(monotext):
		    spaces = 79 - len(monotext)
		self.mono.append(" " * spaces + monotext)

	    self.mono_blankline()
	    self.mono_words = []

	    self.news_show_para()
	    if self.news_bullet_wid:
		self.news_bullet_txt = ""
	    self.news_blankline()
	    spaces = (72 - len(newstext)) / 2
	    if spaces < 0:
		spaces = 0
	    self.news.append(" " * spaces + newstext)
	    self.news_blankline()
	    self.news_words = []
	else:
	    self.mono_add_word(text, ATTR_URL, 0)
	    self.news_add_word(text, 0)

    def name(self, text):
	if self.html_ok:
	    self.html = self.html + "<lj user=\"" + text + "\">"
	elif self.html_title:
	    self.subj = self.subj + "<lj user=\"" + text + "\">"

    def posturlmode(self, on, image):
        self.mono_ok = self.news_ok = (on == 0)
	self.html_ok = (on == 0 or image == 0)

    def postnamemode(self, on):
        self.html_ok = (on == 0)

    def linkstart(self, url):
	if self.html_ok:
	    self.html = self.html + "<a href=\"" + url + "\">"

    def linkend(self):
	if self.html_ok:
	    self.html = self.html + "</a>"

    def posttitlemode(self, on):
        self.html_ok = self.html_title = (on == 0)
        self.news_ok = (on == 0)

    def end_title(self):
        self.mono_attr = self.mono_attr & ~ATTR_UNDER

    def word(self, text):
	if self.html_ok or self.html_title:
	    # Special case: a dash by itself in a word is replaced
	    # by a Unicode en-dash.
	    if text == "-":
		htmltext = "&#8211;"
	    else:
		htmltext = self.htmlsafe(text)
	    if self.html_title:
		self.subj = self.subj + htmltext
	    else:
		self.html = self.html + htmltext
	    if text[-1:] == "-":
		# discretionary break after hyphen
		self.html = self.html + "<wbr>"
        if self.mono_ok:
            self.mono_add_word(text, self.mono_attr, 0)
        if self.news_ok:
            self.news_add_word(text, 0)

    def special(self, keyword):
	if keyword == "pound":
	    if self.html_ok:
		self.html = self.html + "&#163;"
	    if self.mono_ok:
		self.mono_add_word("L", self.mono_attr, 0)
	    if self.news_ok:
		self.news_add_word("L", 0)
	elif keyword == "tm":
	    if self.html_ok:
		self.html = self.html + "&#8482;"
	    if self.mono_ok:
		self.mono_add_word("(TM)", self.mono_attr, 0)
	    if self.news_ok:
		self.news_add_word("(TM)", 0)
	elif keyword == "R":
	    if self.html_ok:
		self.html = self.html + "&#174;"
	    if self.mono_ok:
		self.mono_add_word("(R)", self.mono_attr, 0)
	    if self.news_ok:
		self.news_add_word("(R)", 0)
	elif keyword[:1] == "&":
	    if self.html_ok:
		self.html = self.html + keyword
	    if self.mono_ok:
		self.mono_add_word(keyword[1:2], self.mono_attr, 0)
	    if self.news_ok:
		self.news_add_word(keyword[1:2], 0)

    def whitespace(self, text):
	if self.html_ok:
	    self.html = self.html + self.htmlsafe(text)
	elif self.html_title:
	    self.subj = self.subj + text
        if self.mono_ok and len(self.mono_words) > 0:
            self.mono_add_word(text, self.mono_attr, 1)
        if self.news_ok and len(self.news_words) > 0:
            self.news_add_word(text, 1)

    def default_mbreak(self):
	# Invent an mbreak paragraph with default text in it.
	self.begin_para(PMBREAK)
	if len(self.mono_title) > 0:
	    for x, y, z in self.mono_title:
		self.mono_add_word(x, y, z)
	    self.whitespace(" ")
	    self.word("(part")
	    self.whitespace(" ")
	    self.word("%d)" % self.mono_edit_count)
	else:
	    self.word("(continued)")
	self.end_para(PMBREAK)

# Read input.

TSIMPLE = 0
TOPEN = 1
TCLOSE = 2
WORD = 3
WHITE = 4
NL = 5
PARA = 6
EOF = 7

# Tokenise. Potential tokens are
#
#  - A simple tag, such as {Q}. Return is (TCLOSED,"Q").
#  - An opening tag, such as {q. Return is (TOPEN,"q").
#  - A closing tag (}). Return is (TCLOSE,).
#  - A word. Return is (WORD,"word").
#  - Some whitespace. Return is (WHITE," ").
#  - A lone newline. Return is (NL,).
#  - A paragraph separator. Return is (PARA,).
#  - EOF. Return is (EOF,).

class tokeniser:
    def __init__(self, file):
	self.file = file
	self.currchar = ""
	self.pushback = []
	self.token = None
	self.white_maybe_ignore = 0

    def char(self):
	if self.currchar == "":
	    if len(self.pushback) > 0:
		self.currchar = self.pushback[-1]
		self.pushback = self.pushback[:-1]
	    else:
		self.currchar = self.file.read(1)
	    if self.currchar == "{":
		c = self.file.read(1)
		if c == "}":
		    self.currchar = None
		elif c != "{":
		    self.pushback.append(c)
		    self.currchar = "{{"
	    elif self.currchar == "}":
		c = self.file.read(1)
		if c != "}":
		    self.pushback.append(c)
		    self.currchar = "}}"
	return self.currchar

    def nextchar(self):
	self.currchar = ""
	return self.char()

    def readtoken(self):
	c = None
	white_maybe_ignore = self.white_maybe_ignore
	self.white_maybe_ignore = 0
	while c == None:
	    c = self.char()
	    if c == None:
		self.nextchar()
	if c == "":
	    return (EOF,)
	if c == "\n":
	    if self.nextchar() == "\n":
		self.nextchar()
		return (PARA,)
	    return (NL,)
	if c == "}}":
	    c = self.nextchar()
	    if c != None and len(c) == 1 and c in string.whitespace:
		self.white_maybe_ignore = 1
	    return (TCLOSE,)
	if c == "{{":
	    ret = ""
	    while 1:
		c = self.nextchar()
		if c != None and len(c) == 1 and not (c in string.whitespace):
		    ret = ret + c
		else:
		    break
	    if c == "}}":
		self.nextchar()
		return (TSIMPLE, ret)
	    else:
		if c == None or (len(c) == 1 and c in string.whitespace):
		    self.nextchar()
		return (TOPEN, ret)
	if c in string.whitespace:
	    ret = c
	    while 1:
		c = self.nextchar()
		if c == None:
		    continue
		if len(c) != 1 or not (c in string.whitespace):
		    break
		ret = ret + c
	    if c == "}}" and white_maybe_ignore:
		self.nextchar()
		return (TCLOSE,)
	    return (WHITE, ret)
	# Anything remaining is WORD.
	ret = c
	neednext = 1
	while 1:
	    if neednext:
		c = self.nextchar()
	    neednext = 1
	    if c == None:
		break
	    if len(c) == 1 and not (c in string.whitespace):
		ret = ret + c
	    else:
		break
	    if c == "-":
		# A hyphen breaks, but only between two
		# alphanumerics, and only _after_ adding it to the
		# word.
		if len(ret) > 1 and ret[-2] in (string.digits+string.letters):
		    c2 = self.nextchar() # eat the hyphen
		    if len(c2) > 1:
			# A magic brace character immediately
			# follows the hyphen. Hence, we just add
			# the hyphen to the word and do nothing
			# magical.
			break
		    elif c2 in (string.digits+string.letters):
			break # discretionary word break
		    else:
			neednext = 0 # don't lose the char after the hyphen
	return (WORD, ret)

    def curr(self):
	if self.token == None:
	    self.token = self.readtoken()
	return self.token
    
    def next(self):
	self.token = None
	return self.curr()

    def expect(self, list):
	t = self.curr()
	if not (t[0] in list):
	    sys.stderr.write("unexpected token type\n")
	    return 0
	else:
	    return 1

# Now actually read the markup.

def rdinput(file):
    global nocomments

    t = tokeniser(file)
    o = output()

    # Tokens which immediately end a paragraph.
    endpara = [
    (TSIMPLE,"Q"), (TSIMPLE,"q"), (TSIMPLE,"/q"), (TSIMPLE,"/Q"),
    (TSIMPLE,"story"), (TSIMPLE,"/story"),
    (TSIMPLE,"pre"), (TSIMPLE,"b"), (TSIMPLE, "mbreak"), 
    (TOPEN, "ljcut"), (TOPEN, "mbreak"), (TOPEN, "t"), (TOPEN, "tq"),
    (TOPEN, "tlj"), (TOPEN, "tonly"),
    (PARA,), (EOF,)]

    # Accented characters which can be easily replaced with their
    # unaccented forms.
    accented = {
    "Agrave":1, "Aacute":1, "Acirc":1, "Atilde":1, "Auml":1,
    "Aring":1, "Ccedil":1, "Egrave":1, "Eacute":1, "Ecirc":1,
    "Euml":1, "Igrave":1, "Iacute":1, "Icirc":1, "Iuml":1,
    "Ntilde":1, "Ograve":1, "Oacute":1, "Ocirc":1, "Otilde":1,
    "Ouml":1, "Oslash":1, "Ugrave":1, "Uacute":1, "Ucirc":1,
    "Uuml":1, "Yacute":1, "agrave":1, "aacute":1, "acirc":1,
    "atilde":1, "auml":1, "aring":1, "ccedil":1, "egrave":1,
    "eacute":1, "ecirc":1, "euml":1, "igrave":1, "iacute":1,
    "icirc":1, "iuml":1, "ntilde":1, "ograve":1, "oacute":1,
    "ocirc":1, "otilde":1, "ouml":1, "oslash":1, "ugrave":1,
    "uacute":1, "ucirc":1, "uuml":1, "yacute":1, "yuml":1,
    "Scaron":1, "scaron":1, "Yuml":1,
    }

    while 1:
	# We begin in start-of-paragraph state, where paragraph-
	# level directives such as {Q} take effect.
	para_type = PNORMAL
	stack = [] # open tags in the paragraph

	while 1:
	    tok = t.curr()
	    if tok == (EOF,):
		o.finish()
		return o
	    elif tok == (TSIMPLE, "nocomments"):
		t.next()
		nocomments = 1
	    elif tok == (TSIMPLE, "story"):
		t.next()
		o.quote_state(3)
	    elif tok == (TSIMPLE, "Q"):
		t.next()
		o.quote_state(2)
	    elif tok == (TSIMPLE, "q"):
		t.next()
		o.quote_state(1)
	    elif tok == (TSIMPLE, "/Q") or tok == (TSIMPLE, "/q") or \
	    tok == (TSIMPLE, "/story"):
		t.next()
		o.quote_state(0)
	    elif tok == (TSIMPLE, "pre"):
		t.next()
		para_type = PPRE
	    elif tok == (TSIMPLE, "talker"):
		t.next()
		para_type = PTALKER
	    elif tok == (TSIMPLE, "b"):
		tok2 = t.next()
		para_type = PBULLET
		# Special case: eat whitespace immediately following a bullet.
		if tok2[0] == WHITE:
		    t.next()
	    elif tok == (TOPEN, "ljcut"):
		text = []
		tok = t.next()
		while tok != (TCLOSE,):
		    if t.expect((WORD, WHITE, NL)):
			text.append(tok)
		    tok = t.next()
		t.next() # swallow the close
		o.ljcut(text)
	    elif tok == (TSIMPLE, "/ljcut"):
		t.next()
		o.ljcut(None)
	    elif tok == (TOPEN, "mbreak"):
		t.next()
		stack = ["mbreak"]
		para_type = PMBREAK
		break
	    elif tok == (TSIMPLE, "mbreak"):
		t.next()
		o.default_mbreak()
		continue
	    elif tok == (TOPEN, "t"):
		t.next()
		stack = ["t"]
		para_type = PTITLE
		break
	    elif tok == (TOPEN, "tq"):
		t.next()
		stack = ["tq"]
		para_type = PTITLEQUIET
		break
	    elif tok == (TOPEN, "tlj") or tok == (TOPEN, "tonly"):
		t.next()
		stack = ["tonly"]
		para_type = PTITLEONLY
		break
	    elif tok == (NL,) or tok == (PARA,) or tok == (WHITE,):
		t.next()
		pass # ignore these between paragraphs
	    else:
		# Oh, all right; drop into mid-para mode.
		break

	# Now we're in a paragraph.
	o.begin_para(para_type)
	while 1:
	    tok = t.curr()
	    if tok in endpara:
		o.end_para(para_type)
		if tok[0] == PARA or tok[0] == EOF:
		    t.next()
		break
	    if tok[0] == TSIMPLE:
		t.next()
		if isint(tok[1]):
		    o.footnote(tok[1])
		elif tok[1] == "L":
		    o.special("pound")
		elif accented.has_key(tok[1]):
		    o.special("&" + tok[1] + ";")
		elif tok[1] == "TM":
		    o.special("tm")
		elif tok[1] == "R":
		    o.special("R")
		elif tok[1] == "br":
		    tok2 = t.curr()
		    # Skip line break just before end of paragraph.
		    if not (tok2 in endpara):
			o.line_break()
		    # Eat a real line break immediately following a {br}.
		    if tok2[0] == NL:
			t.next()
		elif tok[1] == "tl":
		    if para_type != PTALKER:
			sys.stderr.write("{tl} tag not in {talker} para\n")
		    else:
			o.tlbegin()
			o.tlend()
		elif tok[1] == "tb":
		    if para_type != PTALKER:
			sys.stderr.write("{tb} tag not in {talker} para\n")
		    else:
			o.tb()
		else:
		    sys.stderr.write("unknown tag `" + tok[1] + "'\n")
	    elif tok[0] == TOPEN:
		if tok[1] == "url" or tok[1] == "img":
		    img = (tok[1] == "img")
		    tok = t.next()
		    url = ""
		    mode = 1
		    while tok != (EOF,):
			if mode == 1 and tok[0] == WORD:
			    url = url + tok[1]
			    tok = t.next()
			elif mode == 1:
			    if tok == (TCLOSE,):
				o.url(url, 1, img)
				t.next()
				break
			    o.url(url, 0, img)
			    if tok[0] == WHITE or tok[0] == NL:
				t.next()
			    o.posturlmode(1, img)
			    # Subsequent stuff inside this element
			    # will be treated normally.
			    stack = stack + ["url"]
			    break
		elif tok[1] == "link":
		    tok = t.next()
		    url = ""
		    while tok != (EOF,):
			if tok[0] == WORD:
			    url = url + tok[1]
			    tok = t.next()
			else:
			    if tok == (TCLOSE,):
				o.warn("{link} with no text after URL!");
				t.next()
				break
			    o.linkstart(url)
			    if tok[0] == WHITE or tok[0] == NL:
				t.next()
			    # Subsequent stuff inside this element
			    # will be treated normally.
			    stack = stack + ["link"]
			    break
		elif tok[1] == "name":
		    tok = t.next()
		    name = ""
		    while tok != (EOF,) and tok != (TCLOSE,):
			if tok[0] == WORD:
			    name = name + tok[1]
			    tok = t.next()
			else:
			    o.name(name)
			    o.postnamemode(1)
			    if tok[0] == WHITE or tok[0] == NL:
				t.next()
			    # Subsequent stuff will be treated
			    # normally.
			    stack = stack + ["name"]
			    break
		elif tok[1] == "tl":
		    if para_type != PTALKER:
			sys.stderr.write("{tl} tag not in {talker} para\n")
		    else:
			tok = t.next()
			name = ""
			o.tlbegin()
			if tok[0] == WHITE or tok[0] == NL:
			    t.next()
			stack = stack + ["tl"]
		else:
		    stack = stack + [tok[1]]
		    t.next()
		    if tok[1] == "q":
			o.quote(1)
		    elif tok[1] == "e":
			o.emph(1)
		    elif tok[1] == "c":
			o.code(1)
		    elif tok[1] == "b":
			o.bold(1)
		    else:
			sys.stderr.write("unknown tag `" + tok[1] + "'\n")
	    elif tok[0] == TCLOSE:
		t.next()
		if len(stack) == 0:
		    sys.stderr.write("unexpected `}'\n")
		else:
		    s = stack[-1]
		    stack = stack[:-1]
		    if s == "q":
			o.quote(0)
		    elif s == "e":
			o.emph(0)
		    elif s == "c":
			o.code(0)
		    elif s == "b":
			o.bold(0)
		    elif s == "url":
			o.posturlmode(0, 0)
		    elif s == "link":
			o.linkend()
		    elif s == "name":
			o.postnamemode(0)
		    elif s == "tl":
			o.tlend()
		    elif s == "t" or s == "tlj" or s == "tonly":
			o.end_title()
		    elif s == "tq":
			o.end_title()
			o.posttitlemode(1)
		    elif s == "mbreak":
			o.end_para(para_type)
			break
	    elif tok[0] == WORD:
                tok2 = t.next()
		o.word(tok[1])
                if tok2[0] == WORD:
                    o.whitespace("") # discretionary break
	    elif para_type == PPRE and tok[0] == NL:
		t.next()
		o.line_break()
	    elif para_type == PPRE and tok[0] == WHITE:
		t.next()
		o.whitespace(tok[1])
	    elif tok[0] == NL or tok[0] == WHITE:
		t.next()
		o.whitespace(" ")

def readfile(fname):
    f = open(fname, "r")
    s = f.readline()
    if s[:3] != "-*-":
	# Oops, in our attempt to skip the -*- line we've stupidly
	# eaten a line of the real file. Close and reopen.
	f.close()
	f = open(fname, "r")
    ret = rdinput(f)
    f.close()
    return ret

# Main program.
#  - Get a filename on stdin; invent a temp name if none given.
#  - Run an editor over the file if it's new or empty.
#  - Prompt for action: preview Mono, preview HTML, or post.

need_edit = 1
need_unlink = 0
nocomments = 0
security = None
fname = None
if len(sys.argv) > 1:
    doing_args = 1
    for arg in sys.argv[1:]:
	if arg[0:1] == "-" and doing_args:
	    if arg == "--":
		doing_args = 0
	    elif arg[0:2] == "-s" and len(arg) > 2:
		security = arg[2:]
		if not (security in ["private", "public"]):
		    sys.stderr.write("warning: unrecognised security value" +\
		    " \"" + security + "\"\n")
	else:
	    if fname != None:
		sys.stderr.write("warning: ignoring additional argument \"" +\
		arg + "\"\n")
	    else:
		fname = arg

if fname != None:
    try:
	s = os.stat(fname)
	if s[6] > 0:
	    need_edit = 0
    except OSError:
	pass
else:
    tempfile.template = "diary-"
    fname = tempfile.mktemp()
    need_edit = 1
    need_unlink = 1

if need_edit:
    f = open(fname, "w")
    f.write("-*- diary -*-\n\n")
    f.close()
    os.system(os.environ["VISUAL"] + " +3 " + fname)

now = time.time()
nowlocal = time.localtime()

while 1:
    try:
	out = readfile(fname)
	warnings = out.warnings
    except IOError:
	warnings = ["Unable to open file for processing."]

    if len(warnings) == 0:
	warnings = ["File looks OK."]

    for i in warnings:
	print i
    print

    sys.stdout.write("Edit again, preview Mono, preview Html, preview News,\n")
    sys.stdout.write("Post (to Mono only / Lj / News), Abort? [EMHNPA] ")
    try:
	s = sys.stdin.readline()
    except KeyboardInterrupt:
	s = ""
    if s == "" or s == "a\n":
	print
	print "Quitting."
	break
    s = string.lower(s)
    if s == "e\n":
	os.system(os.environ["VISUAL"] + " " + fname)
	continue

    if not (s in ["m\n", "h\n", "n\n", "p\n", "pm\n", "pl\n", "pn\n"]):
	print "Unknown command."
	print
	continue

    now = time.time()
    nowlocal = time.localtime()

    out = readfile(fname)

    if s == "m\n":
	f = os.popen("mtribs | less -r", "w")
	# For preview purposes, assume a plausible nameline
	for i in out.mono:
	    if i == "\031":
		i = "\007B\007CRFrom: \007CGinsert nameline here"
	    f.write(i + "\n")
	f.close()
    elif s == "n\n":
	f = os.popen("less -r", "w")
	for i in out.news:
	    f.write(i + "\n")
	f.close()
    elif s == "h\n":
	f = os.popen("fold -w79 | less -r", "w")
	f.write("Subject: " + out.subj + "\n\n")
	f.write(out.html)
	f.close()
    elif s == "p\n" or s == "pm\n" or s == "pl\n" or s == "pn\n":
	f = open(os.environ["HOME"] + "/src/lj/diary.data", "w")
	g = os.popen("xcopy -C 2>/dev/null", "w")
	h = os.popen("wclip 2>/dev/null", "w")
	data = out.mono + [\
	"Message: 7fffffff","From: (dummy edit)", "Please ignore this."]
	for i in data:
	    try:
		f.write(i + "\n")
	    except IOError:
		pass
	    try:
		g.write(i + "\n")
	    except IOError:
		pass
	    try:
		h.write(i + "\n")
	    except IOError:
		pass
	f.close()
	g.close()
	h.close()
	print "Mono text written to diary.data file and piped through xcopy."
	print "Don't forget to have your nameline in the ^Y paste buffer!"
	if s == "p\n" or s == "pl\n":
	    dict = {"mode":"postevent", "lineendings":"unix"}
	    dict["event"] = out.html
	    if out.subj != "":
		dict["subject"] = out.subj
	    dict["year"] = time.strftime("%Y", nowlocal)
	    dict["mon"] = time.strftime("%m", nowlocal)
	    dict["day"] = time.strftime("%d", nowlocal)
	    dict["hour"] = time.strftime("%H", nowlocal)
	    dict["min"] = time.strftime("%M", nowlocal)
	    if security:
		dict["security"] = security
	    if nocomments:
		dict["prop_opt_nocomments"] = "1"
	    ret = ljproto.ljcall(dict)
	    if not ljproto.ljok(ret):
		print "Unable to post to LJ: " + ljproto.ljerror(ret)
		need_unlink = 0
	    else:
		print "Posted to LJ; itemid =", ret["itemid"]
	else:
	    print "Not posted to LJ (restricted command given)"
	if s == "p\n" or s == "pn\n":
	    f = os.popen("inews", "w")
	    for i in out.news:
		f.write(i + "\n")
	    if f.close():
		print "Posting to news returned an error code"
	    else:
		print "Posted to news."
	else:
	    print "Not posted to news (restricted command given)"
	break

if need_unlink:
    os.unlink(fname)
