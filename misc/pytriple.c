/*
 * Generate Pythagorean triples on standard output, as an open-ended
 * text stream (well, at least until unsigned long long runs out of
 * space).
 *
 * We use the result that every primitive (i.e. in lowest terms)
 * integer Pythagorean triple x^2+y^2=z^2, up to swapping of x with
 * y, is generated by exactly one pair of positive integers (u,v)
 * such that u > v, u and v are coprime, and exactly one is odd,
 * using Euclid's formula:
 *
 *   x = u^2 - v^2
 *   y = 2uv
 *   z = u^2 + v^2
 *
 * So we iterate over all such pairs with 1 <= v < u. To output the
 * tuples in a sensible order (we sort primarily by the hypotenuse
 * z, and secondarily by x having normalised every tuple to have
 * x<y) we use a binary heap which contains the next pair to be
 * processed for each value of u. So our procedure is to remove the
 * smallest tuple from the heap and print it, then advance its value
 * of v and re-add it, unless doing so makes v=u in which case that
 * tuple can be discarded. Meanwhile, we also have to start fresh
 * values of u when it becomes possible that they should be the next
 * one to be printed.
 *
 * To generate _all_ tuples (the -a option), we must also retain
 * every primitive tuple we've found, and manually calculate all its
 * multiples to add to the heap. (With the constraints on u,v
 * removed, the above formula unhelpfully generates some _but not
 * all_ of the non-primitive tuples.)
 *
 * An output option -v causes the values of u, v and the scale
 * factor to be printed for every tuple output.
 *
 * A numeric argument will cause the program to terminate after
 * generating all tuples with z less than the given number. With no
 * such argument it will continue running until it runs out of
 * memory or suffers integer overflow.
 */

/*
 * Proofs of the needed results:
 *
 * Every u,v generates a Pythagorean triple
 * ----------------------------------------
 *
 * Obvious from the definitions: (u^2-v^2)^2 + (2uv)^2 = (u^2+v^2)^2
 * is trivially proved by multiplying out all the brackets. []
 *
 * Every primitive Pythagorean triple is generated by some u,v
 * -----------------------------------------------------------
 *
 * Let x^2+y^2=z^2 be a Pythagorean triple in lowest terms.
 *
 * If x and y are both even, then z is even too and the triple
 * cannot be in lowest terms. On the other hand, if they're both odd
 * then their squares are both congruent to 1 mod 4, so z^2 would
 * have to be congruent to 2 mod 4, which no perfect square can be.
 * Hence, we know exactly one of x and y is odd - WLOG let it be x -
 * and therefore z is also odd.
 *
 * Now if x and z are odd, then z+x and z-x are both even, so if we
 * call them 2m and 2n respectively then we have x=m-n and z=m+n for
 * positive integers m>n. Then y^2 = (m+n)^2 - (m-n)^2 = 4mn. So
 * 4mn, and hence mn, must be a perfect square.
 *
 * m and n must be coprime (2 cannot divide both since z is odd, and
 * any prime other than 2 dividing both would also divide x, z, y^2,
 * and hence y, so the triple would not be in lowest terms).
 * Therefore, if mn is a perfect square then so are m and n. Write
 * m=u^2 and n=v^2, and the result follows. []
 *
 * No triple is generated by more than one u,v
 * -------------------------------------------
 *
 * Certainly any two distinct (u,v) pairs most give rise to distinct
 * ordered tuples (u^2-v^2,2uv,u^2+v^2), just by observing that the
 * sum and difference of the first and last elements of the latter
 * tuple give 2u^2 and 2v^2 respectively. So the only way that two
 * pairs u,v could generate the same _unordered_ tuple would be if
 * the two shorter sides were swapped: that is, we would need
 * u,v,u',v' such that
 *
 *   u^2-v^2 = 2u'v'       (1)
 *       2uv = u'^2-v'^2   (2)
 *   u^2+v^2 = u'^2+v'^2   (3)
 *
 * But adding equations (1) and (3) and factorising the RHS tells us
 * that 2u^2 = (u'+v')^2, which can't happen since no two perfect
 * squares can differ by a factor of two. []
 *
 * u,v are coprime and exactly one odd => the triple is primitive
 * --------------------------------------------------------------
 *
 * If exactly one of u,v is odd, then u^2-v^2 and u^2+v^2 are odd
 * while 2uv is even, hence 2 does not divide the whole triple.
 *
 * If any odd prime divides the whole triple then it would have to
 * divide (z-x) = 2v^2 and hence divide v, and also divide (z+x) =
 * 2u^2 and hence divide u. []
 *
 * The triple is primitive => u,v are coprime and exactly one odd
 * --------------------------------------------------------------
 *
 * If u,v were both odd or both even, then every element of the
 * triple would be even.
 *
 * If any odd prime divides both u and v, then it would divide the
 * whole triple. []
 *
 * Not all non-primitive tuples are generated
 * ------------------------------------------
 *
 * Consider x=15,y=20,z=25 (scaling up 3,4,5 by 5). We would need
 * 2uv=20 => uv=10, so u,v would have to be either 10,1 or 5,2. But
 * those pairs are both coprime and have exactly one odd, therefore
 * they both generate primitive tuples (respectively 99,20,101 and
 * 21,20,29); hence 15,20,25 cannot be generated by any u,v. []
 */

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <err.h>

static unsigned long long gcd(unsigned long long a, unsigned long long b)
{
    while (b != 0) {
	unsigned long long t = a % b;
	a = b;
	b = t;
    }
    return a;
}

struct tuple {
    unsigned long long u, v, s, x, y, z;
};

struct tuple *heap = NULL;
int heaplen = 0, heapsize = 0;

#define COMPARE(v1,v2) \
    ((v1).z < (v2).z ? -1 : (v1).z > (v2).z ? +1 : \
     (v1).x < (v2).x ? -1 : (v1).x > (v2).x ? +1 : 0)

#define HPARENT(i) (((i)-1)/2)
#define HLCHILD(i) (2*(i)+1)
#define HRCHILD(i) (2*(i)+2)

void addheap(struct tuple val)
{
    int i;

    if (heaplen >= heapsize) {
	heapsize = heaplen * 3 / 2 + 512;
	heap = realloc(heap, heapsize * sizeof(*heap));
	if (!heap)
	    errx(1, "out of memory");
    }

    i = heaplen++;
    heap[i] = val;
    while (i > 0 && COMPARE(heap[i], heap[HPARENT(i)]) < 0) {
	int j = HPARENT(i);
	struct tuple tmp = heap[j];
	heap[j] = heap[i];
	heap[i] = tmp;
	i = j;
    }
}

void rmheap(void)
{
    int i;

    assert(heaplen > 0);

    heap[0] = heap[--heaplen];
    i = 0;
    while (HLCHILD(i) < heaplen) {
	int j = i;

	if (/* HLCHILD(i) < heaplen && */
	    COMPARE(heap[HLCHILD(i)], heap[i]) < 0)
	    j = HLCHILD(i);

	if (HRCHILD(i) < heaplen &&
	    COMPARE(heap[HRCHILD(i)], heap[j]) < 0)
	    j = HRCHILD(i);

	if (j != i) {
	    struct tuple tmp = heap[j];
	    heap[j] = heap[i];
	    heap[i] = tmp;
	    i = j;
	} else
	    break;
    }
}

struct tuple construct(unsigned long long u, unsigned long long v,
		       unsigned long long s)
{
    struct tuple val;
    unsigned long long a, b;
    val.u = u;
    val.v = v;
    val.s = s;
    a = u*u - v*v;
    b = 2*u*v;
    val.z = s * (u*u + v*v);
    val.x = s * (a < b ? a : b);
    val.y = s * (a > b ? a : b);
    return val;
}

int main(int argc, char **argv)
{
    unsigned long long umax;
    struct tuple val, newval;
    int multiples = 0, verbose = 0;
    unsigned long long zlimit = 0;

    while (--argc > 0) {
	char *p = *++argv;
	if (!strcmp(p, "-a"))
	    multiples = 1;
	else if (!strcmp(p, "-v"))
	    verbose = 1;
	else if (p[0] && isdigit((unsigned char)p[0]))
	    zlimit = strtoull(p, NULL, 0);
	else
	    errx(1, "unrecognised option '%s'", p);
    }

    umax = 2;			       /* the smallest u we will ever try */

    while (1) {
	while (1) {
	    /*
	     * Start new values of u, by adding to the heap a tuple
	     * constructed from the new u and the smallest v it will
	     * go with (i.e. either 1 or 2, for even or odd u
	     * respectively).
	     *
	     * We must obviously do this if the heap is empty
	     * (otherwise there's nowhere we can get more tuples
	     * from), and we must also do it if the new u,v pair
	     * would yield a hypotenuse with a chance of being the
	     * smallest one in the heap.
	     */
	    unsigned long long u = umax;
	    unsigned long long v = (u & 1) + 1;
	    if (heaplen > 0 && heap[0].z < u*u + v*v)
		break;		       /* we're OK for now */
	    newval = construct(u, v, 1);
	    if (!zlimit || newval.z < zlimit)
		addheap(newval);
	    else
		break;
	    umax++;
	}

	if (heaplen == 0)
	    return 0;		       /* terminated due to reaching zlimit */

	/*
	 * Remove the smallest tuple from the heap (according to our
	 * sorting criterion as described above), and print it.
	 */
	val = heap[0];
	rmheap();
	if (verbose)
	    printf("%llu %llu %llu : ", val.u, val.v, val.s);
	printf("%llu %llu %llu\n", val.x, val.y, val.z);

	/*
	 * If we're printing non-primitive tuples, then after
	 * printing any tuple we must re-add to the heap the next
	 * scaled-up multiple of its base tuple.
	 */
	if (multiples) {
	    newval = construct(val.u, val.v, val.s + 1);
	    if (!zlimit || newval.z < zlimit)
		addheap(newval);
	}

	/*
	 * If we've just generated a primitive tuple, we should work
	 * out whether there are any more valid values of v to go
	 * with its u, and add the next one to the heap if so.
	 */
	if (val.s == 1) {
	    while ((val.v += 2) < val.u) {
		if (gcd(val.u, val.v) == 1) {
		    newval = construct(val.u, val.v, 1);
		    if (!zlimit || newval.z < zlimit)
			addheap(newval);
		    break;
		}
	    }
	}
    }
}
