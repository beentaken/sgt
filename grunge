#!/usr/bin/env python

import sys
import string
import time
import os
import curses

import rgtpclient

# Read .grungerc
if os.environ.has_key("GRUNGEDIR"):
    rcdir = os.environ["GRUNGEDIR"]
else:
    rcdir = os.environ["HOME"]
rcpath = os.path.normpath(os.path.join(rcdir, ".grungerc"))
secretpath = os.path.normpath(os.path.join(rcdir, ".groggsecret"))
indexpath = os.path.normpath(os.path.join(rcdir, ".grungeindex"))
rc = open(rcpath, "r")
rcfile = {}
while 1:
    line = rc.readline()
    if line == "":
	break
    if line[-1:] == "\n":
	line = line[:-1]
    space = string.find(line, " ")
    if space != -1:
	rcfile[line[:space]] = line[space+1:]
rc.close()

def centre(texts):
    centrelen = 0
    for i in range(0, len(texts), 2):
	centrelen = centrelen + len(texts[i])
    left = (width - centrelen) / 2
    s = " " * left
    for i in texts:
	s = s + i
    return s

def initcurses():
    global scr, height, width, scrheight, scrwidth
    scr = curses.initscr()
    scr.keypad(1)
    scr.scrollok(1)
    curses.noecho()
    scrheight, scrwidth = scr.getmaxyx()
    height, width = scrheight, scrwidth - 1

def endcurses():
    scr.erase()
    scr.refresh()
    curses.endwin()

def aprint(scr, y, x, str):
    attr = 0
    while str != "":
	i = string.find(str, "\a")
	if i == -1: i = len(str)
	scr.addstr(y, x, str[:i], attr)
	str = str[i:]
	x = x + i
	if str == "": break
	elen = 2
	if str[1] == "B": attr = attr | curses.A_BOLD
	if str[1] == "b": attr = attr &~ curses.A_BOLD
	if str[1] == "R": attr = attr | curses.A_REVERSE
	if str[1] == "r": attr = attr &~ curses.A_REVERSE
	if str[1] == "a": attr = 0
	if str[1] == "C": elen = 3
	str = str[elen:]

def mylc(i):
    if i >= ord("A") and i <= ord("Z"):
	i = i + ord("a") - ord("A")
    return i

def formatheader(texts):
    centrelen = 0
    for i in range(0, len(texts), 2):
	centrelen = centrelen + len(texts[i])

    tildelen = width-10
    left = (tildelen - centrelen) / 2
    right = (tildelen - centrelen) - left

    line = "\aB\aR\aCB\aCw <| \aCa\aCC\aa "
    line = line + " " * left
    for i in texts:
	line = line + i
    line = line + " " * right
    line = line + " \aB\aR\aCB\aCw <| \aa"
    list = [line]
    
    line = "\aB\aR\aCB\aCw _/ \aCa\aCC\aa "
    line = line + "~" * tildelen
    line = line + " \aB\aR\aCB\aCw _/ \aa"
    list = list + [line]
    return list

def formatitem(item):
    "Format an item. Return as a list of non-LF-terminated strings"
    list = []

    subjtrunc = item.subject
    if len(subjtrunc) > width-21:
	subjtrunc = subjtrunc[:width-24] + "..."
    centrelen = len(subjtrunc) + 11; # space < 8-char-itemid >

    list = formatheader([subjtrunc + " <", "\aB", item.itemid, "\ab", ">"])

    list = list + [item.itemid + ": " + item.subject, ""]
    if item.contfrom:
	list = list + ["(Continued from " + item.contfrom + ")", ""]
    for j in item.contribs:
	list = list + ["\aR\aB\aCb" + "-" * (width-28) + \
	"[\ab" + time.ctime(j.timestamp) + "\aB]--\aa\aCA"]
	# "From: grogname (userid)"
	# length 9 + lengrogname + lenuserid
	grogname = j.grogname
	userid = j.userid
	if len(grogname) + len(userid) + 9 > width:
	    newgrognamelen = width - len(userid) - 9 - 3;
	    if newgrognamelen < 0: newgrognamelen = 0
	    grogname = grogname[:newgrognamelen] + "..."
	if len(grogname) + len(userid) + 9 > width:
	    newuseridlen = width - len(userid) - 9 - 3;
	    if newuseridlen < 0: newuseridlen = 0
	    userid = userid[:newuseridlen] + "..."
	list = list + ["From: \aB\aCG" + grogname + \
	" (" + userid + ")\aa\aCA", ""]
	list = list + j.data[j.skip:j.end] + [""]
    if item.contin:
	list = list + ["\aR\aB\aCG" + "-" * width + "\aa\aCA", ""]
	centretext = "(Continued in " + item.contin + ")"
	left = (width - len(centretext)) / 2
	list = list + ["\aCR" + " "*left + centretext + "\aCA"]

    return list

def getinput(prompt, inittext):
    "Get bottom-line input"
    maxlen = width - len(prompt)
    ret = ""
    while 1:
	scr.addstr(height-1, 0, " " * width)
	scr.addstr(height-1, 0, prompt + ret)
	scr.move(height-1, len(prompt) + len(ret))
	scr.refresh()
	c = scr.getch()
	if c == ord("\n") or c == ord("\r"):
	    return ret
	elif c == ord("\010") or c == ord("\177"):
	    if len(ret) > 0:
		ret = ret[:-1]
	elif c == ord("\025"):
	    while len(ret) > 0:
		ret = ret[:-1]
	elif c >= 32 and c <= 126:
	    if len(ret) < maxlen:
		ret = ret + chr(c)

def pageitem(indexentry, item, override):
    "Page through an item. Might return an itemid to go to instead."
    class holder:
	"Holding class"
    h=holder()
    def printbl(h=h):
	bl = ""
	bll = 0
	if h.y < h.ymax:
	    bl = bl + "[\aBSPACE\ab]:More  "
	    bll = bll + 5+5+4
	elif h.continued:
	    bl = bl + "[\aB>\ab]:Next  "
	    bll = bll + 5+1+4
	if h.y > 0:
	    bl = bl + "[\aB-\ab]:Up  "
	    bll = bll + 5+1+2
	elif h.contfrom:
	    bl = bl + "[\aB<\ab]:Previous  "
	    bll = bll + 5+1+8
	if h.y < h.ymax:
	    bl = bl + "[\aBQ\ab]:Exit  "
	    bll = bll + 5+1+4
	else:
	    bl = bl + "[\aBQ\ab]/[\aBRET\ab]:Exit  "
	    bll = bll + 5+1+3+3+4
	if h.addable:
	    bl = bl + "[\aBA\ab]:Add  "
	    bll = bll + 5+1+3
	percent = (h.y + height-1) * 100 / (h.ymax + height-1)
	blp = "(" + "%d" % percent + "%)"
	bl = bl + blp
	bll = bll + len(blp)
	left = (width-bll)/2
	if left < 0: left = 0
	scr.addstr(height-1, 0, " "*width)
	aprint(scr, height-1, 0, " "*left + bl)
	scr.refresh()
    def erasebl():
	scr.addstr(height-1, 0, " "*width)
	scr.refresh()
    try:
	data = formatitem(item)
	h.ymax = len(data) - height + 1
	if h.ymax < 0: h.ymax = 0
	if override == 1:
	    h.y = 0
	elif override == 2 or indexentry.uptodate:
	    h.y = h.ymax
	else:
	    h.y = indexentry.fileptr - (height-1)
	if h.y < 0: h.y = 0
	if h.y > h.ymax: h.y = h.ymax
	# FIXME: check write access on whole session
	h.addable = (item.contin == "")
	h.contfrom = (item.contfrom != "")
	h.continued = (item.contin != "")
	if h.ymax < 0: h.ymax = 0
	searchtext = ""
	redraw = 1
	while 1:
	    # Redraw if necessary
	    if redraw:
		scr.erase()
		for i in range(h.y, h.y+height-1):
		    if i < len(data):
			aprint(scr, i - h.y, 0, data[i])
		printbl()
		redraw = 0
	    # Update file pointer
	    indexentry.fileptr = h.y+height-1
	    if indexentry.fileptr >= len(data):
		indexentry.fileptr = len(data)
		indexentry.uptodate = 1
	    else:
		indexentry.uptodate = 0
	    # Get a character
	    c = mylc(scr.getch())
	    # Oddity: Return at end of item becomes Q.
	    if (c == ord("\n") or c == ord("\r")) and h.y == h.ymax:
		c = ord("q")
	    # Now process keypresses properly.
	    if c == ord(" ") or c == ord("+") or c == ord("\n") or \
	    c == ord("\r") or c == curses.KEY_DOWN or c == curses.KEY_RIGHT:
		dist = { ord(" "): height-2, ord("+"): height-2, \
		curses.KEY_RIGHT: height-2, ord("\n"): 1, ord("\r"): 1, \
		curses.KEY_DOWN: 1 }[c]
		newy = h.y + dist
		if newy > h.ymax: newy = h.ymax
		erasebl()
		for i in range(h.y+height-1, newy+height-1):
		    scr.scroll(1)
		    aprint(scr, height-2, 0, data[i])
		h.y = newy
		printbl()
	    elif c == ord("b") or c == ord("-") or c == curses.KEY_LEFT or c == curses.KEY_UP:
		dist = { ord("b"): height-2, ord("-"): height-2, \
		curses.KEY_LEFT: height-2, curses.KEY_UP: 1 }[c]
		newy = h.y - dist
		if newy < 0: newy = 0
		for i in range(h.y-1, newy-1, -1):
		    scr.scroll(-1)
		    aprint(scr, 0, 0, data[i])
		h.y = newy
		printbl()
	    elif c == ord("<"):
		if item.contfrom != "":
		    return item.contfrom, 2
	    elif c == ord(">"):
		if item.contin != "":
		    return item.contin, 1
	    elif c == ord("/"):
		text = getinput("Search (blank=last): ", "", width, height)
		if text != "": searchtext = text
		ysrch = h.y + height - 1
		while ysrch < len(data):
		    if string.find(data[ysrch], searchtext) != -1:
			break
		    ysrch = ysrch + 1
		else:
		    ysrch = len(data)-1
		    curses.beep()
		if ysrch > h.ymax: ysrch = h.ymax
		h.y = ysrch - (height - 2)
		if h.y < 0: h.y = 0 # shouldn't happen
		redraw = 1
	    elif c == ord("g"):
		text = getinput("Goto line (now " + "%d"%h.y + "), or end" +\
		" with % for percent: ", "", width, height)
		try:
		    if text[-1:] == "%":
			ygoto = h.ymax * string.atoi(text[:-1]) / 100
		    else:
			ygoto = string.atoi(text)
		except ValueError:
		    ygoto = h.y
		if ygoto < 0:
		    ygoto = 0
		    curses.beep()
		if ygoto > h.ymax:
		    ygoto = h.ymax
		    curses.beep()
		if h.y != ygoto:
		    redraw = 1
		    h.y = ygoto
		else:
		    erasebl()
		    printbl()
	    elif c == ord("0"):
		h.y = 0
		redraw = 1
	    elif c == ord("z"):
		h.y = h.ymax
		redraw = 1
	    elif c == ord("q"):
		break
	    elif c == ord("a"):
		if h.addable:
		    return "a", 0
    finally:
	scr.erase()
    return "", 0

class item:
    "holding class"

def parseindex(index, items):
    contseq = -1
    conttime = -1
    contitem = contin = None
    for e in index:
	if e.itemid != "":
	    if not items.has_key(e.itemid):
		items[e.itemid] = item()
		items[e.itemid].itemid = e.itemid
		items[e.itemid].fileptr = 0
		items[e.itemid].uptodate = 0
		items[e.itemid].subscription = 3 # both scans
		items[e.itemid].contfrom = None
		items[e.itemid].contin = None
	    i = items[e.itemid]
	else:
	    i = None
	if i != None and e.subject != "":
	    i.subject = e.subject
	if e.type == "F": # continuation of this item
	    i.timestamp = e.timestamp
	    if contin != None and contseq == e.sequence and conttime == e.timestamp:
		i.contin = contin.itemid
		contin.contfrom = i.itemid
		contin.subscription = i.subscription
		contitem = contin = None
	    else:
		contseq = e.sequence
		conttime = e.timestamp
		contitem = i
	    i.uptodate = 0
	    i.newtext = 1
	elif e.type == "C": # new continuation
	    i.timestamp = e.timestamp
	    if contitem != None and contseq == e.sequence and conttime == e.timestamp:
		i.contfrom = contitem.itemid
		contitem.contin = i.itemid
		i.subscription = contitem.subscription
		contitem = contin = None
	    else:
		contseq = e.sequence
		conttime = e.timestamp
		contin = i
	    i.newtext = 1
	elif e.type == "R" or e.type == "E": # reply or edit
	    i.timestamp = e.timestamp
	    i.uptodate = 0
	    i.newtext = 1
	    if e.type == "E":
		i.fileptr = 0 # effectively new
	elif e.type == "I": # new item
	    i.timestamp = e.timestamp
	    i.newtext = 1
    return items

def saveindex(filename, items, lastseq):
    def stripL(s):
	if s[-1:] == "L":
	    s = s[:-1]
	return s
    f = open(filename, "w")
    f.write(stripL(repr(lastseq)) + "\n")
    for i, v in items.items():
	f.write(v.itemid + " " + repr(v.timestamp))
	f.write(" " + "%d" % v.fileptr + " " + "%d" % v.uptodate)
	f.write(" " + "%d" % v.subscription)
	if v.contfrom:
	    f.write(" " + v.contfrom)
	else:
	    f.write(" -")
	if v.contin:
	    f.write(" " + v.contin)
	else:
	    f.write(" -")
	f.write(" s=" + v.subject + "\n")
    f.close()

def loadindex(filename):
    items = {}
    try:
	f = open(filename, "r")
    except IOError:
	return {}, -1L
    lastseq = string.atoi(f.readline())
    while 1:
	s = f.readline()
	if s == "": break
	while s[-1:] == "\n": s = s[:-1]
	words = string.split(s)
	subjpos = string.find(s, "s=")
	i = item()
	i.itemid = words[0]
	i.timestamp = string.atof(words[1])
	i.fileptr = string.atoi(words[2])
	i.uptodate = string.atoi(words[3])
	i.subscription = string.atoi(words[4])
	i.contfrom = words[5]
	if i.contfrom == "-": i.contfrom = None
	i.contin = words[6]
	if i.contin == "-": i.contin = None
	i.subject = s[subjpos+2:]
	i.newtext = 0
	items[i.itemid] = i
    return items, lastseq

class menu:
    "Class describing a Grunge menu context"
    def _fmtline(self, line):
	key, type, aux, text = line
	i = string.find(text, "&")
	if i != -1:
	    text = text[:i] + "\aB\aCG" + text[i+1:i+2] + "\aCA\ab" + text[i+2:]
	if type == "t":
	    return centre([aux])
	elif type == "i":
	    s = "\aCB" + aux.itemid + "\aCA  ("
	    lt = time.localtime(aux.timestamp)
	    ltnow = time.localtime(time.time())
	    if lt[0] < ltnow[0]-1 or (lt[0] == ltnow[0]-1 and lt[1] <= ltnow[1]):
		s = s + time.strftime("%b %d  %Y", lt)
	    else:
		s = s + time.strftime("%b %d %H:%M", lt)
	    s = s + ") "
	    if aux.subscription == 3: # both scans
		s = s + " "
	    elif aux.subscription == 2: # second scan only
		s = s + "-"
	    elif aux.subscription == 0: # neither scan
		s = s + "="
	    else:
		s = s + "\aCR?\aCA" # erroneous scan status
	    s = s + "[\aB" + string.upper(key) + "\ab] "
	    if aux.uptodate:
		s = s + "- "
	    elif aux.fileptr == 0:
		s = s + "\aCY*\aCA "
	    else:
		s = s + "\aCR+\aCA "
	    if aux.contin: # this is a continued item
		s = s + "\aCY  " # indent and yellow the subject line
	    subj = aux.subject
	    remainingwidth = width - 36
	    if len(subj) > remainingwidth:
		subj = subj[:remainingwidth-3] + "..."
	    s = s + subj
	    if aux.contin: # this is a continued item
		s = s + "\aCA" # indent and yellow the subject line
	    return s
	elif type == "m" or type == "s":
	    if type == "m" and aux.hasitems:
		s = "\aCC%8d" % aux.itemcount + " items\aCA   "
	    else:
		s = "                 "
	    if type == "m":
		s = s + "  Menu"
	    else:
		s = s + "Action"
	    s = s + "   [\aB"
	    s = s + string.upper(key) + "\ab] "
	    if type == "m":
		s = s + "= "
	    else:
		s = s + "- "
	    s = s + text
	    return s
	# FIXME: need  "Menu  [ESC]= Utilities & EXIT"
	return centre(["(nyi menu entry)"])
    def __init__(self, flags, title):
	self.lines = []
	self.title = title
	self.parent = None
	self.chars = "abcdefghijklmnoprstuvwxyz1234567890"
	self.scannable = (flags & 1) != 0
	self.hasitems = (flags & 2) != 0
	self.itemcount = 0
    def addchild(self, childmenu, key, text):
	self.lines.append((key, "m", childmenu, text))
	childmenu.parent = self
    def addspecial(self, special, key, text):
	self.lines.append((key, "s", special, text))
    def additem(self, itemid, key=""):
	if key == "":
	    key = self.chars[0]
	    self.chars = self.chars[1:] + key
	self.lines.append((key, "i", itemid, ""))
	self.itemcount = self.itemcount + 1
    def addblank(self):
	self.lines.append(("", "t", "", ""))
    def show(self, ytop):
	def printbl(up, down, self=self):
	    bl = ""
	    bll = 0
	    sep = ""
	    if self.parent != None:
		bl = bl + sep + "[\aBRET\ab]:Back"
		bll = bll + len(sep) + 3+3+4
		sep = "  "
	    if self.scannable:
		bl = bl + sep + "[\aBSPACE\ab]:Scan"
		bll = bll + len(sep) + 3+5+4
		sep = "  "
	    if self.itemcount > 0:
		bl = bl + sep + "[\aB=\ab]:Subscribe"
		bll = bll + len(sep) + 3+1+9
		sep = "  "
	    if up:
		bl = bl + sep + "[\aB-\ab]"
		bll = bll + len(sep) + 2+1
		sep = "  "
	    if down:
		bl = bl + sep + "[\aB+\ab]"
		bll = bll + len(sep) + 2+1
		sep = "  "
	    if sep == "":
		bl = bl + "Select key"
		bll = bll + 10
	    bl = bl + "."
	    bll = bll + 1
	    left = (width-bll)/2
	    if left < 0: left = 0
	    scr.addstr(height-1, 0, " "*width)
	    aprint(scr, height-1, 0, " "*left + bl)
	    scr.refresh()

	hdr = formatheader(self.title)
	scr.erase()
	sy = 0
	for i in hdr:
	    aprint(scr, sy, 0, i)
	    sy = sy + 1
	sy = sy + 1
	y = ytop
	keysused = {}
	while y < len(self.lines) and sy < height-1:
	    if keysused.has_key(self.lines[y][0]):
		break
	    aprint(scr, sy, 0, self._fmtline(self.lines[y]))
	    y = y + 1
	    sy = sy + 1
	printbl(ytop > 0, y < len(self.lines))
	return y
    def ok(self, y):
	if y < 0: return 0
	if y > len(self.lines)-1: return 0
	return 1
    def lookup(self, key, ystart, yend):
	for i in range(ystart, yend):
	    if self.lines[i][0] == key:
		return self.lines[i]
	return None
    def suball(self, sub):
	for i in self.lines:
	    if i[1] == "i":
		i[2].subscription = sub
    def setallread(self):
	for i in self.lines:
	    if i[1] == "i":
		i[2].uptodate = 1
    def scan(self):
	for scan in [1,2]:
	    for i in self.lines:
		if i[1] == "i" and not i[2].uptodate and (i[2].subscription & scan):
		    return self, i[2].itemid
	    for i in self.lines:
		if i[1] == "m":
		    m, itemid = i[2].scan()
		    if itemid != "":
			return m, itemid
	return self, ""

def mkmenus(items):
    now = time.time()
    oneweek = now - 7*24*60*60
    onemonth = now - 30*24*60*60
    sixmonths = now - 182*24*60*60
    oneyear = now - 365*24*60*60

    Mmain = menu(1,["Grunge Main Menu"])
    Mnew = menu(3,["Newly Updated Items <", "\aB", "N", "\ab", ">"])
    Msub = menu(3,["Subscribed Items <", "\aB", "S", "\ab", ">"])
    Mboth = menu(3,["Both Scans <", "\aB", "B", "\ab", ">"])
    Moneweek = menu(3,["One Week <", "\aB", "W", "\ab", ">"])
    Monemonth = menu(3,["One Month <", "\aB", "M", "\ab", ">"])
    Msixmonths = menu(3,["Six Months <", "\aB", "6", "\ab", ">"])
    Moneyear = menu(3,["One Year <", "\aB", "Y", "\ab", ">"])
    Mallitems = menu(3,["All Items <", "\aB", "A", "\ab", ">"])
    Mitemid = menu(3,["Sorted by Itemid <", "\aB", "I", "\ab", ">"])
    Mescape = menu(0,["Utilities [", "\aB", "ESC", "\ab", "]"])
    Mlogs = menu(0,["Logs and MOTD [", "\aB", "ESC", "\ab", "][",\
    "\aB", "L", "\ab", "]"])
    Mlogslogs = menu(0,["Logs Menu [", "\aB", "ESC", "\ab", "][",\
    "\aB", "L", "\ab", "][", "\aB", "L", "\ab", "]"])
    Mexit = menu(0,["Exit Grunge? [", "\aB", "ESC", "\ab", "][",\
    "\aB", "X", "\ab", "]"])

    Mmain.addchild(Mnew, "n", "Items with &new text this session")
    Mmain.addblank()
    Mmain.addchild(Moneweek, "w", "Items modified up to a &week ago")
    Mmain.addchild(Monemonth, "m", "Items modified up to a &month ago")
    Mmain.addchild(Msixmonths, "6", "Items modified up to &6 months ago")
    Mmain.addchild(Moneyear, "y", "Items modified up to a &year ago")
    Mmain.addblank()
    Mmain.addchild(Msub, "s", "&Subscribed items")
    Mmain.addchild(Mboth, "b", "Items subscribed on &both scans")
    Mmain.addblank()
    Mmain.addchild(Mallitems, "a", "&All items")
    Mmain.addblank()
    Mmain.addchild(Mitemid, "i", "All items, sorted by &itemid")

    Mescape.addchild(Mmain, "g", "&Go to Main Menu", )
    Mescape.addblank()
    Mescape.addchild(Mlogs, "l", "&Logs and MOTD")
    Mescape.addblank()
    Mescape.addspecial("youropts", "y", "Set &your options")
    Mescape.addblank()
    Mescape.addchild(Mexit, "x", "E&xit Grunge")

    Mexit.addchild(Mmain, "n", "&No, return to Main Menu")
    Mexit.addspecial("exit", "x", "Yes, really e&xit Grunge")

    Mlogs.addchild(Mlogslogs, "l", "&Logs")
    Mlogs.addblank()
    Mlogs.addspecial("motd", "v", "&View Message Of The Day")

    Mlogslogs.addspecial("editlog", "e", "&Edit Log")

    itemlist = items.items()
    def itemcompare(a, b, items=items):
	def foremost(x, items=items):
	    # Find foremost item in chain.
	    level = 0
	    while x.contin != None:
		x = items[x.contin]
		level = level+1
	    return x, level
	ai, alevel = foremost(a[1])
	bi, blevel = foremost(b[1])
	# Reverse-order on timestamp.
	if ai.timestamp < bi.timestamp: return +1
	if ai.timestamp > bi.timestamp: return -1
	# Next, positive-order on level.
	if alevel < blevel: return -1
	if alevel > blevel: return +1
	# Failing that, positive-order on itemid.
	if a[0] < b[0]: return -1
	if a[0] > b[0]: return +1
	# Itemids identical? Give up.
	return 0
    itemlist.sort(itemcompare)
    for id, item in itemlist:
	if item.newtext: Mnew.additem(item)
	if item.timestamp > oneweek: Moneweek.additem(item)
	if item.timestamp > onemonth: Monemonth.additem(item)
	if item.timestamp > sixmonths: Msixmonths.additem(item)
	if item.timestamp > oneyear: Moneyear.additem(item)
	if item.subscription != 0: Msub.additem(item)
	if item.subscription == 3: Mboth.additem(item)
	Mallitems.additem(item)
    def itemidcompare(a,b):
	if a[0] < b[0]: return -1
	if a[0] > b[0]: return +1
	# Itemids identical? Give up.
	return 0
    itemlist.sort(itemidcompare)
    for id, item in itemlist:
	Mitemid.additem(item)

    Mmain.parent = None # special case
    Mlogs.parent = Mmain # special case

    return (Mmain, Mescape)

def showmenus(mainmenu, escmenu, startmenu):
    try:
	m = startmenu
	my = 0
	while 1:
	    myb = m.show(my)
	    if m.scannable:
		mret = m
	    else:
		mret = mainmenu
	    c = mylc(scr.getch())
	    if c == ord("\033"):
		m = escmenu
		my = 0
	    elif c == ord("q") or c == ord("\r") or c == ord("\n"):
		if m.parent != None:
		    m = m.parent
		    my = 0
	    elif c == ord("+"):
		newy = my + (height-4)
		if m.ok(newy): my = newy
	    elif c == ord("-"):
		newy = my - (height-4)
		if m.ok(newy): my = newy
	    elif c == ord("q"):
		if m.parent != None:
		    m = m.parent
		    my = 0
	    elif c == ord("\010") or c == ord("\177"):
		m.setallread()
	    elif c == ord(" "):
		if m.scannable:
		    m, itemid = m.scan()
		    if itemid != "":
			return ("i", itemid, m)
	    elif c == ord("="):
		if m.itemcount > 0:
		    prompt = ["Select key from list, [",
		    "\aB", "=", "\ab", "]:All, [",
		    "\aB", "Q", "\ab", "]:Quit"]		
		    scr.addstr(height-1, 0, " "*width)
		    aprint(scr, height-1, 0, centre(prompt, width))
		    scr.refresh()
		    k = mylc(scr.getch())
		    klookup = m.lookup(chr(k), my, myb)
		    if k == ord('=') or klookup != None:
			b = []
			foo = 7
			if klookup:
			    if klookup[2].subscription == 0:
				b = b + ["Currently skipped on both scans.  ", ""]
				foo = foo & ~4
			    elif klookup[2].subscription == 2:
				b = b + ["Currently skipped on first scan.  ", ""]
				foo = foo & ~2
			    elif klookup[2].subscription == 3:
				b = b + ["Currently checked on both scans.  ", ""]
				foo = foo & ~1
			    else:
				b = b + ["Scan status corrupt.  ", ""]
			for i in range(3):
			    if foo & (1<<i):
				b = b + ["[", "\aB", chr(48+i), "\ab",
				"]:" + ("Don't skip", "Skip scan 1",
				"Skip both scans")[i] + "  ", ""]
			b = b + ["[", "\aB", "Q", "\ab", "]"]
			scr.addstr(height-1, 0, " "*width)
			aprint(scr, height-1, 0, centre(b, width))
			scr.refresh()
			s = mylc(scr.getch())
			if s >= ord("0") and s <= ord("2"):
			    sub = { ord("0"):3, ord("1"):2, ord("2"):0 }[s]
			    if klookup != None:
				klookup[2].subscription = sub
			    else:
				m.suball(sub)
	    else:
		result = m.lookup(chr(c), my, myb)
		if result != None:
		    if result[1] == "m":
			m = result[2]
			my = 0
		    elif result[1] == "i":
			return ("i", result[2].itemid, mret)
		    elif result[1] == "s":
			return ("s", result[2], mret)
    finally:
	scr.erase()

def editor(title, inittext):
    def redraw(content, yoff):
	for i in range(len(content)):
	    aprint(scr, yoff+i, 0, content[i])
    def wordbegin(s, x, wordchars=string.letters+"-"):
	"Determine whether s has a word-beginning at point x"
	if x == 0:
	    return 1
	if not (s[x] in wordchars):
	    return 0
	if s[x-1] in wordchars:
	    return 0
	return 1
    lwidth = 75
    insert = 1 # FIXME: permament insert-mode setting
    try:
	scr.erase()
	hdr = formatheader(title)
	sy = 0
	for i in hdr:
	    aprint(scr, sy, 0, i)
	    sy = sy + 1
	aprint(scr, sy, 0, centre(["Enter '", "\aB", ".", "\ab",
	"' on a line to finish, '", "\aB", ".quit", "\ab", "' or [",
	"\aB", "^O", "\ab", "][", "\aB", "Q","\ab","] to quit."]))
	sy = sy + 1
	aprint(scr, sy, 0, centre(["[", "\aB", "^O", "\ab", "] for options ([",
	"\aB", "CTRL", "\ab", "] + [", "\aB", "O","\ab","])"]))
	sy = sy + 1
	aprint(scr, sy, 0, "\aR\aCB\aCc" + "-"*(lwidth-1) + "|" +
	"-"*(width-lwidth) + "\aa\aCA\aCa")
	yoff = 5
	ynum = height - yoff
	content = [" " * lwidth] * ynum
	linecutbuf = ""
	ret = inittext
	if len(ret) == 0:
	    ret = [""]
	y = len(ret)-1
	x = len(ret[y])
	ytop = 0
	while 1:
	    redraw(content, yoff)
	    scr.move(y-ytop+yoff, x)
	    scr.refresh()
	    c = scr.getch()
	    cnext = None
	    if c == ord("\017"): # ^O prefixes things
		cnext = mylc(scr.getch())
	    # FIXME: ^V, ^Z move by screenfuls.
	    #
	    # FIXME: ^K, ^Y c'n'p.
	    # FIXME: ^O M/B for block motion.
	    #
	    # FIXME: ^O F for search (*shrug*).
	    # FIXME: ^O J to justify paragraph.
	    if c == ord("\n") or c == ord("\r"):
		if ret[y] == ".quit":
		    return None # quit editor
		if ret[y] == ".":
		    ret[y:y+1] = [] # erase the line with a dot
		    break
		ret[y:y+1] = [ret[y][:x], ret[y][x:]]
		x = 0
		y = y + 1
		if ytop < y-ynum+1: ytop = y-ynum+1
	    elif cnext == ord("q"):
		return None # ^O q quits
	    elif cnext == ord(" "):
		break # ^O space terminates
	    elif c == ord("\001"):
		x = 0
	    elif c == ord("\005"):
		x = len(ret[y])
	    elif c == ord("\010") or c == ord("\177"):
		if x > 0:
		    ret[y] = ret[y][:x-1] + ret[y][x:]
		    x = x - 1
		elif y > 0 and len(ret[y-1]) + len(ret[y]) <= lwidth:
		    x = len(ret[y-1])
		    ret[y-1:y+1] = [ret[y-1] + ret[y]]
		    y = y - 1
	    elif c == ord("\004"):
		if x < len(ret[y]):
		    ret[y] = ret[y][:x] + ret[y][x+1:]
		elif y+1 < len(ret) and len(ret[y]) + len(ret[y+1]) <= lwidth:
		    ret[y:y+2] = [ret[y] + ret[y+1]]
	    elif c == ord("\020") or c == curses.KEY_UP:
		if y > 0:
		    y = y - 1
		    if ytop > y: ytop = y
		    if x > len(ret[y]): x = len(ret[y]) # FIXME: fix x
		else:
		    x = 0
	    elif c == ord("\006") or c == curses.KEY_RIGHT: # Right
		if x < len(ret[y]):
		    x = x + 1
		elif y < len(ret)-1:
		    x = 0
		    y = y + 1
		    if ytop < y-ynum+1: ytop = y-ynum+1
	    elif c == ord("\024"): # word right
		if x < len(ret[y]):
		    x = x + 1
		    while x < len(ret[y]) and not wordbegin(ret[y],x):
			x = x + 1
		elif y < len(ret)-1:
		    x = 0
		    y = y + 1
		    if ytop < y-ynum+1: ytop = y-ynum+1
	    elif c == ord("\027"): # word left
		if x > 0:
		    x = x - 1
		elif y > 0:
		    y = y - 1
		    if ytop > y: ytop = y
		    x = len(ret[y])
		while x < len(ret[y]) and not wordbegin(ret[y],x):
		    x = x - 1
	    elif c == ord("\013"): # cut to eol
		if x < len(ret[y]):
		    linecutbuf = ret[y][x:]
		    ret[y] = ret[y][:x]
		elif y+1 < len(ret) and len(ret[y]) + len(ret[y+1]) <= lwidth:
		    ret[y:y+2] = [ret[y] + ret[y+1]]
	    elif c == ord("\031"): # paste the line cut buffer
		if len(ret[y]) + len(linecutbuf) <= lwidth:
		    ret[y] = ret[y][:x] + linecutbuf + ret[y][x:]
		    x = x + len(linecutbuf)
	    elif c == ord("\016") or c == curses.KEY_DOWN:
		if y < len(ret)-1:
		    y = y + 1
		    if ytop < y-ynum+1: ytop = y-ynum+1
		    if x > len(ret[y]): x = len(ret[y]) # FIXME: fix x
		else:
		    x = len(ret[y])
	    elif c == ord("\006") or c == curses.KEY_LEFT:
		if x > 0:
		    x = x - 1
		elif y > 0:
		    y = y - 1
		    if ytop > y: ytop = y
		    x = len(ret[y])
	    elif c >= 32 and c <= 126:
		ret[y] = ret[y][:x] + chr(c) + ret[y][x+1-insert:]
		x = x + 1
		py = y
		while len(ret[py]) > lwidth:
		    # We have wrapped. Trim a space if that's all we need
		    # to do, otherwise find a whole word and wrap it.
		    while len(ret[py]) > lwidth and ret[py][-1:] == " ":
			ret[py] = ret[py][:-1]
		    if x > len(ret[py]): # special case: Space pressed at EOL
			x = 0
			y = y + 1
			wrap = ""
		    else:
			sp = string.rfind(ret[py], " ", 0, lwidth)
			if sp == -1:
			    wrap = ret[py][lwidth:]
			    ret[py] = ret[py][:lwidth]
			    if y == py and x > lwidth:
				y = y + 1
				x = x - lwidth
			else:
			    wrap = ret[py][sp+1:]
			    ret[py] = ret[py][:sp]
			    if y == py and x > sp:
				y = y + 1
				x = x - (sp+1)
		    py = py + 1
		    if len(ret) == py or ret[py] == "":
			ret[py:py] = [wrap]
		    else:
			ret[py] = wrap + " " + ret[py]
	    # Now redraw content to match editor buffer
	    for i in range(0, ynum):
		if i+ytop < len(ret):
		    content[i] = (ret[i+ytop] + " "*lwidth) [:lwidth]
		else:
		    content[i] = " "*lwidth
    finally:
	scr.erase()
    # Trim trailing blank lines
    while len(ret) > 0 and ret[-1] == "":
	ret = ret[:-1]
    return ret

def addpage(pagetype, grogname, itemid):
    "Display the `add edit?' pages. pagetype=0 is normal; pagetype=1 means\n"\
    "the item is full and needs continuing; pagetype=2 means the item has\n"\
    "already been continued; pagetype=3 means the item has been modified\n"\
    "but not continued.\n"\
    "Returns an action, the maybe-modified grogname, and the subject for\n"\
    "a new continuation."
    scr.erase()
    y = 0
    if pagetype == 0:
	title = ["Add contribution to item " + itemid]
    elif pagetype == 1:
	title = ["Item " + itemid + " is full"]
    elif pagetype == 2:
 	title = ["Item has already been continued in " + itemid]
    elif pagetype == 3:
 	title = ["Item " + itemid + " has already been replied to"]
    hdr = formatheader(title)
    for i in hdr:
	aprint(scr, y, 0, i)
	y = y + 1
    y = y + 1
    if pagetype == 1:
	aprint(scr, y, 0, "    Your contribution is big enough to push"+
	" item "+itemid+" beyond the size")
	y=y+1
	aprint(scr, y, 0, "    limit. You can add it as a continuation item.")
	y=y+2
    elif pagetype == 2:
	aprint(scr, y, 0, "    The item you tried to contribute to has"+
	" already been continued. You")
	y=y+1
	aprint(scr, y, 0, "    can add your contribution to the continuation"+
	" item, "+itemid+".")
	y=y+2
    elif pagetype == 3:
	aprint(scr, y, 0, "    The item you tried to contribute to has"+\
	" already been modified. You")
	y=y+1
	aprint(scr, y, 0, "    can add your contribution anyway.")
	y=y+2
    if pagetype == 1:
	aprint(scr, y, 0, "    [\aBSPACE\ab] - Add your comment as a"+
	" continuation.")
	y=y+1
	spaceaction = "cont"
    else:
	aprint(scr, y, 0, "    [\aBSPACE\ab] - Save your comment to item "+\
	itemid+".")
	y=y+1
	spaceaction = "reply"
    y=y+1
    aprint(scr, y, 0, "        [\aBQ\ab] - Quit. (leave item unaltered)")
    y=y+1
    aprint(scr, y, 0, "        [\aBA\ab] - Re-edit comment.")
    y=y+1
    subj = ""
    while 1:
	aprint(scr, y, 0, "        [\aBN\ab] - Grogname \""+grogname+"\"")
	aprint(scr, height-1, 0, centre(["======== Please select an option ========"]))
	scr.refresh()
	c = mylc(scr.getch())
	if c == ord(" "):
	    if spaceaction == "cont":
		subj = getinput("Enter subject line:", "", 80, 24)
	    return spaceaction, grogname, subj
	elif c == ord("a"):
	    return "edit", grogname, subj
	elif c == ord("q"):
	    return "quit", grogname, subj
	elif c == ord("n"):
	    grogname = getinput("Enter name: ", grogname, 80, 24)

server = "rgtp-serv.groggs.group.cam.ac.uk"
port = 1431
if rcfile.has_key("server"):
    server = rcfile["server"]
if rcfile.has_key("port"):
    port = string.atoi(rcfile["port"])

args = sys.argv[1:]
logfile = None
dump = 0
while len(args) > 0 and args[0][:1] == "-":
    if args[0] == "-d":
	logfile = sys.stderr
    if args[0] == "-e":
	# Editor test. FIXME: this wants removing.
	try:
	    initcurses()
	    text = editor(["Editor Test [", "\aB", "grunge -e", "\ab", "]"], [])
	finally:
	    endcurses()
	for i in text:
	    print ">", i, "<"
	sys.exit(0)
    if args[0] == "-dump":
	dump = 1
	c = rgtpclient.RGTPConnection(host=server, port=port, plogfile=logfile)
	c.setsecret(os.path.normpath(os.path.join(os.environ["HOME"], ".groggsecret")))
	c.login(rcfile["userid"])
	itm = c.item(args[1])
	c.close()
	for i in formatitem(itm):
	    print i
	sys.exit(0)
    if args[0] == "-c":
	# Check for new GROGGS but don't start the reader.
	c = rgtpclient.RGTPConnection(host=server, port=port, plogfile=logfile)
	c.setsecret(os.path.normpath(os.path.join(os.environ["HOME"], ".groggsecret")))
	c.login(rcfile["userid"])
	items, lastseq = loadindex(indexpath)
	index = c.index(sequence=lastseq+1)
	c.close()
	if index != []:
	    print "You have new GROGGS!"
	    sys.exit(0)
	sys.exit(1)
    args[:1] = []

def indexupdate(c, items, lastseq):
    index = c.index(sequence=lastseq+1)
    if len(index) > 0:
	lastseq = index[-1].sequence
    items = parseindex(index, items)
    return items, lastseq

# Todo list:
#
# Introduce ESC N (or at least ESC Something) for start-brand-new-item.
#
# Line editing and recall in bottom-line input.
#
# Support the REGU procedure, using --register and also offer to do it
# if no .grungerc is found. (It's easy! Send REGU, wait for non-100,
# if it's 250 then display resulting message, prompt for userid, send USER,
# and display resulting response, if it wasn't 250 then just display it.
# Finally, send QUIT and leave peacefully.)
#
# Accumulated FIXMEs from elsewhere in the code:
# - Check session has write access when deciding whether to print [A]:Add
# - "Menu  [ESC]= Utilities and Exit"
# - Implement missing features in editor.
# - Set Your Options (grogname and maybe others)
# - View MOTD.
# - View Edit Log.

c = rgtpclient.RGTPConnection(host=server, port=port, plogfile=logfile)
c.setsecret(secretpath)
c.login(rcfile["userid"])

items, lastseq = loadindex(indexpath)
items, lastseq = indexupdate(c, items, lastseq)
saveindex(indexpath, items, lastseq)
mainmenu, escmenu = mkmenus(items)
menu = mainmenu
try:
    initcurses()
    while 1:
        t, aux, menu = showmenus(mainmenu, escmenu, menu)
        if t == "s" and aux == "exit":
	    break
        elif t == "i":
	    override = 0
	    while len(aux) > 1:
	        itemid = aux
	        itm = c.item(aux)
	        aux, override = pageitem(items[aux], itm, override)
	    if aux == "a":
	        text = []
	        grogname = rcfile["grogname"]
	        action = "edit"
	        pagetype = 0
	        while 1:
		    if action == "quit":
		        break
		    elif action == "edit":
		        text = editor(["Add to item " + itemid], text)
		        if text == None:
			    break
		        status = "new"
		    elif action == "reply":
		        err = c.senddata([grogname] + text)
		        if err != "":
			    FIXME() # let's have an error page
		        status = c.reply(itemid)
		    elif action[:4] == "cont":
		        err = c.senddata([grogname] + text)
		        if err != "":
			    FIXME() # let's have an error page
		        status = c.cont(itemid, subj)
		    if status == "ok":
		        # Re-update index.
		        items, lastseq = indexupdate(c, items, lastseq)
		        break
		    elif status == "error":
		        FIXME() # let's have an error page
		    else:
		        if status[:4] == "cont":
			    itemid = status[4:]
			    status = "cont"
		        pagetype = {"new":0, "full":1, "cont":2, "mod":3}[status]
		        action, grogname, subj = addpage(pagetype, grogname, itemid)
        else:
	    curses.beep() # NYI specials
        # FIXME: youropts, motd and editlog
finally:
    endcurses()
saveindex(indexpath, items, lastseq)
c.close()
