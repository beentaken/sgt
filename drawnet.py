#!/usr/bin/env python

# Read in a polyhedron description, and draw a net in PostScript.

# TODO
#
#  - Before output run, define canonical position for each output
#    vertex, by finding all vertices in vpos lists which are the
#    same one and averaging them. Simplest way to do this is to
#    divide the polyhedron's edges into folded and cut, and loop
#    over each folded edge, finding the faces on either side of it,
#    and identifying their two copies of the two vertices in
#    question.
#     * Then draw each edge exactly once. A nice way to do this
# 	might be to go round the cut edges in a single closed path,
# 	then separately draw each folded edge. Advantage of this is
# 	that we can make the two edge types look distinct as well.
#
#  - Draw tabs.
#     * Every cut edge appears in two separate places on the net,
# 	and exactly one of those must have a tab. So first loop
# 	over all cut edges to place each tab one by one.
#     * To maintain a large number of faces at the edges of the net
# 	which have no tabs so they can be used as the final face,
# 	perhaps choosing whichever of the two cut edges is closest
# 	to the origin might be an interesting option. Except that
# 	that won't guarantee a tab-free face on the tetrahedron
# 	net, so a slightly more savvy strategy is required. Perhaps
# 	a starting pass which identifies all leaf faces in the net
# 	and arranges for as many as possible to be tab-free?
#     * When actually drawing the tab: first determine the angle of
# 	the tab end lines. Look at all lines leaving the endpoints
# 	of the edge (on the page), measure the angle out from the
# 	edge, and set the tab's end lines to be the minimum such
# 	angle or about 80 degrees, whichever is smaller. Then the
# 	tab is a trapezium generated by cutting off the triangle
# 	made by those lines, parallel to the starting edge. Limit
# 	the height of that trapezium by reference to the face it's
# 	got to be glued on to (this _also_ limits the angles), and
# 	then binary-chop the height down further until you find a
# 	decently big size that doesn't overlap anything else.
#     * Remember to avoid tabs overlapping with other tabs. Which
# 	raises the question, what do you do about it if they do?
# 	Greedily placing tab A and then having a minimal tab B
# 	sounds like an unpleasant solution. Erp.

import sys
import string
import random
from math import pi, asin, atan2, cos, sin, sqrt
from crosspoint import crosspoint

args = sys.argv[1:]

firstface = None
while len(args) > 0 and args[0][:1] == "-":
    a = args[0]
    args = args[1:]

    if a == "--":
	break
    elif a[:2] == "-s":
	firstface = a[2:]
    else:
	sys.stderr.write("ignoring unknown option \"%s\"\n", a)

if len(args) > 0:
    infile = open(args[0], "r")
    args = args[1:]
else:
    infile = sys.stdin

if len(args) > 0:
    outfile = open(args[0], "w")
    args = args[1:]
else:
    outfile = sys.stdout

vertices = {}
faces = {}
normals = {}

lineno = 0
while 1:
    s = infile.readline()
    if s == "": break
    sl = string.split(s)
    lineno = lineno + 1
    if sl[0] == "point" and len(sl) == 5:
	vertices[sl[1]] = \
	(string.atof(sl[2]), string.atof(sl[3]), string.atof(sl[4]))
    elif sl[0] == "face" and len(sl) == 3:
	if not vertices.has_key(sl[2]):
	    sys.stderr.write("line %d: vertex %s not defined\n" % \
	    (lineno, sl[2]))
	else:
	    if not faces.has_key(sl[1]):
		faces[sl[1]] = []
	    faces[sl[1]].append(sl[2])
    elif sl[0] == "normal" and len(sl) == 5:
	if not faces.has_key(sl[1]):
	    sys.stderr.write("line %d: face %s not defined\n" % \
	    (lineno, sl[1]))
	else:
	    normals[sl[1]] = \
	    (string.atof(sl[2]), string.atof(sl[3]), string.atof(sl[4]))
    else:
	sys.stderr.write("line %d: unrecognised line format\n" % lineno)
	continue
infile.close()

def realprint(a, outfile=outfile):
    for i in range(len(a)):
	outfile.write(str(a[i]))
	if i < len(a)-1:
	    outfile.write(" ")
	else:
	    outfile.write("\n")

def psprint(*a):
    realprint(a)

def debug(*a):
    realprint(a, sys.stderr)

def rotatetotop(x, y, z):
    # Return an orthogonal matrix which rotates a given point to
    # the positive z-axis. (Will fail if passed 0,0,0!)
    d = sqrt(x**2+y**2+z**2)
    x = x/d
    y = y/d
    z = z/d
    # We first find the point's polar coordinates...
    theta = atan2(y, x)
    phi = asin(z)
    # ... and construct a matrix which first rotates by -theta
    # about the z-axis, thus bringing the point to the
    # meridian, and then rotates by pi/2-phi about the y-axis
    # to bring the point to (1,0,0).
    #
    # That matrix is therefore
    #
    #  ( cos(pi/2-phi)  0 -sin(pi/2-phi) ) ( cos(-theta) -sin(-theta) 0 )
    #  (       0        1        0       ) ( sin(-theta)  cos(-theta) 0 )
    #  ( sin(pi/2-phi)  0  cos(pi/2-phi) ) (      0            0      1 )
    #
    # which comes to
    #
    #  ( cos(theta)*sin(phi)  sin(theta)*sin(phi)  -cos(phi) )
    #  (     -sin(theta)          cos(theta)           0     )
    #  ( cos(theta)*cos(phi)  sin(theta)*cos(phi)   sin(phi) )
    matrix = [
    [ cos(theta)*sin(phi),  sin(theta)*sin(phi),  -cos(phi) ],
    [     -sin(theta)    ,      cos(theta)     ,      0     ],
    [ cos(theta)*cos(phi),  sin(theta)*cos(phi),   sin(phi) ]]
    return matrix

def zrotate(theta):
    matrix = [
    [ cos(theta), -sin(theta), 0 ],
    [ sin(theta),  cos(theta), 0 ],
    [      0    ,      0     , 1 ]]
    return matrix

def matrixmult(m2, m1):
    matrix = []
    for y in range(3):
	mrow = []
	for x in range(3):
	    s = 0
	    for k in range(3):
		s = s + m2[y][k] * m1[k][x]
	    mrow.append(s)
	matrix.append(mrow)
    return matrix

def transform(matrix, xa, ya, za):
    xb = matrix[0][0] * xa + matrix[0][1] * ya + matrix[0][2] * za
    yb = matrix[1][0] * xa + matrix[1][1] * ya + matrix[1][2] * za
    zb = matrix[2][0] * xa + matrix[2][1] * ya + matrix[2][2] * za
    return xb, yb, zb

# Container class.
class struct:
    pass

# For each face, we store a load of data in facepos[face] about
# where the face has been positioned.
#  - facepos[face].face equals face. Handy back-reference.
#  - facepos[face].matrix is the matrix which rotates the
#    polyhedron so that the x and y components of the face's
#    vertices represent how it is displayed on the plane.
#  - facepos[face].pos is an (x,y) tuple indicating how far the
#    rotated polyhedron is translated to reach its final position.
#  - facepos[face].vpos is a hash mapping vertices to (x,y)
#    positions.
#  - facepos[face].bbox is an (xmin,ymin,xmax,ymax) 4-tuple.
#  - facepos[face].adjacent is a hash mapping other faces to
#    further container classes containing the above `matrix',
#    `pos', `vpos' and `bbox' elements.
facepos = {}

def do_vpos_bbox(placement, face):
    # Find the position of each vertex in face f.
    vpos = {}
    xmin = ymin = xmax = ymax = None
    for v in faces[face]:
	xa, ya, za = vertices[v]
	xb, yb, zb = transform(placement.matrix, xa, ya, za)
	xb = xb + placement.pos[0]
	yb = yb + placement.pos[1]
	vpos[v] = (xb, yb)
	if xmin == None or xmin > xb: xmin = xb
	if ymin == None or ymin > yb: ymin = yb
	if xmax == None or xmax < xb: xmax = xb
	if ymax == None or ymax < yb: ymax = yb
    placement.vpos = vpos
    placement.bbox = (xmin, ymin, xmax, ymax)

# Go through the edges of each face and build up some quick
# reference hashes: one mapping each face to a list of edges, the
# other mapping each edge to the face on its left. (This means we
# represent each edge once in each direction.)
faceedges = {}
edgeface = {}
for face, vlist in faces.items():
    elist = []
    for i in range(len(vlist)):
	elist.append((vlist[i-1], vlist[i])) # Python makes [-1],[0] work :-)
    faceedges[face] = elist
    for edge in elist:
	assert not edgeface.has_key(edge)
	edgeface[edge] = face

# This hash stores a list of unplaced faces.
unplaced = {}
for i in faces.keys():
    unplaced[i] = 1

# This one stores the coordinates of each edge as finally placed on
# the net. (Note that each edge is placed at most twice, once in
# each direction. For folded edges the two are reverses of each
# other, whereas for cut edges they're in totally separate places.)
# Values in this hash are 2-tuples of (x,y) tuples.
edgepos = {}

# Pick an arbitrary face to start off with. Rotate so that its
# normal vector points upwards, and position it at the origin.
if firstface != None and not faces.has_key(firstface):
    sys.stderr.write("supplied initial face name does not exist\n");
    firstface = None
if firstface == None:
    firstface = faces.keys()[0]
nx, ny, nz = normals[firstface]
facepos[firstface] = struct()
facepos[firstface].matrix = rotatetotop(nx, ny, nz)
facepos[firstface].pos = (0,0)
facepos[firstface].face = firstface
do_vpos_bbox(facepos[firstface], firstface)
#debug("initial", firstface, facepos[firstface].vpos)
f = firstface

# List of possible places to put next face. Each one is a tuple of
# (face-to-be-placed, already-placed-face-to-put-it-next-to).
nextface = []

# Loop round placing each face.
while 1:
    #debug("placed", f, "at", facepos[f].pos)

    # We have just placed face f. Mark it as placed.
    del unplaced[f]

    # Go through and record the position of each edge in face f.
    for e in faceedges[f]:
	edgepos[e] = (facepos[f].vpos[e[0]], facepos[f].vpos[e[1]])

    # Figure out where each adjacent face would go if we placed it
    # beside f. Form a list of possible next face placements.
    facepos[f].adjacent = {}
    for e in faceedges[f]:
	e2 = (e[1],e[0])  # the inverse of the edge
	f2 = edgeface[e2] # the face sharing that edge
	# First rotate the normal of f2 to the top.
	nx, ny, nz = normals[f2]
	matrix2 = rotatetotop(nx, ny, nz)
	# Now transform the edge vector, and figure out how much to
	# rotate it about the z-axis to bring it into alignment
	# with the same edge on the face we've just placed.
	xa1, ya1, za1 = vertices[e[0]]
	xb1, yb1, zb1 = transform(matrix2, xa1, ya1, za1)
	xa2, ya2, za2 = vertices[e[1]]
	xb2, yb2, zb2 = transform(matrix2, xa2, ya2, za2)
	dx1 = facepos[f].vpos[e[0]][0] - facepos[f].vpos[e[1]][0]
	dy1 = facepos[f].vpos[e[0]][1] - facepos[f].vpos[e[1]][1]
	dx2 = xb1 - xb2
	dy2 = yb1 - yb2
	theta1 = atan2(dy1, dx1)
	theta2 = atan2(dy2, dx2)
	matrix3 = zrotate(theta1 - theta2)
	matrix = matrixmult(matrix3, matrix2)
	# Now transform the two vertices in question using the new matrix.
	xc1, yc1, zc1 = transform(matrix, xa1, ya1, za1)
	xc2, yc2, zc2 = transform(matrix, xa2, ya2, za2)
	# (Verify that they are what they should be.)
	#debug(dx1, xc1-xc2  # should be equal)
	#debug(dy1, yc1-yc2  # these should be equal too)
	# Now figure out where to translate this face to so that
	# this edge is brought into exact conjunction with the
	# corresponding edge on face f.
	vx1 = facepos[f].vpos[e[0]][0] - xc1
	vx2 = facepos[f].vpos[e[1]][0] - xc2
	vx = (vx1 + vx2) / 2
	vy1 = facepos[f].vpos[e[0]][1] - yc1
	vy2 = facepos[f].vpos[e[1]][1] - yc2
	vy = (vy1 + vy2) / 2
	# Store the matrix and translation data, so that if we do
	# decide to place this face here we don't have to recompute
	# everything.
	facepos[f].adjacent[f2] = struct()
	facepos[f].adjacent[f2].matrix = matrix
	facepos[f].adjacent[f2].pos = (vx, vy)
	facepos[f].adjacent[f2].face = f2
	# Generate vpos and bbox.
	do_vpos_bbox(facepos[f].adjacent[f2], f2)
	#debug("possible", f2, "adjoining", f, facepos[f].adjacent[f2].vpos)
	# Add this to the list of possible next-face placements.
	nextface.append((f2,f))

    # Now we've finished with f, and can reuse the variable.

    # Go through the possible next-face placements and weed out any
    # which overlap an already-placed face, or which _are_ an
    # already-placed face.
    #debug(nextface)
    nfnew = []
    for n, p in nextface:
	if not unplaced.has_key(n): continue
	# For each face, go through all the already-placed faces
	# and see if there's an overlap.
	#debug("testing", n, "adjoining", p)
	placement = facepos[p].adjacent[n]
	overlap = 0
	for f, fplace in facepos.items():
	    # Special case: n and p cannot overlap, although
	    # they're depressingly likely to look as if they do.
	    if f == p: continue
	    
	    # Two faces definitely don't overlap if their bounding
	    # boxes are non-overlapping.
	    if placement.bbox[3] < fplace.bbox[1]: continue
	    if placement.bbox[1] > fplace.bbox[3]: continue
	    if placement.bbox[2] < fplace.bbox[0]: continue
	    if placement.bbox[0] > fplace.bbox[2]: continue
	    #debug("testing overlap between", n, "and", f)

	    # Now we have to figure out whether the polygons
	    # actually intersect. I reckon this will be the case
	    # iff one of two conditions holds: (a) an edge of
	    # polygon A intersects an edge of B, or (b) the
	    # epicentre of one polygon is within the other.
	    for vl1, vl2 in [(placement,fplace), (fplace,placement)]:
		for e1 in faceedges[vl1.face]:
		    # Special case again: if either edge ends at a
		    # vertex of n, an intersection will look very
		    # likely but must actually be ignored.
		    if vl1.face != placement.face and \
		    placement.vpos.has_key(e1[0]): break
		    if vl1.face != placement.face and \
		    placement.vpos.has_key(e1[1]): break
		    for e2 in faceedges[vl2.face]:
			if vl2.face != placement.face and \
			placement.vpos.has_key(e2[0]): break
			if vl2.face != placement.face and \
			placement.vpos.has_key(e2[1]): break
			xa1, ya1 = vl1.vpos[e1[0]]
			xa2, ya2 = vl1.vpos[e1[1]]
			xb1, yb1 = vl2.vpos[e2[0]]
			xb2, yb2 = vl2.vpos[e2[1]]
			ret = crosspoint(xa1,ya1,xa2,ya2,xb1,yb1,xb2,yb2)
			if ret == None: continue
			x, y = ret
			dxa, dya = xa2-xa1, ya2-ya1
			dxb, dyb = xb2-xb1, yb2-yb1
			# See if the crossing point is between the
			# ends of each line. This will be true if
			# the dot product (x-xa1,y-ya1).(dxa,dya)
			# divided by the squared length
			# (dxa,dya).(dxa,dya) is strictly between 0
			# and 1. Likewise for b1/b2.
			dp = ((x-xa1)*dxa+(y-ya1)*dya) / (dxa**2 + dya**2)
			if dp < 0 or dp > 1: continue
			dp = ((x-xb1)*dxb+(y-yb1)*dyb) / (dxb**2 + dyb**2)
			if dp < 0 or dp > 1: continue
			# We have an intersection.
			#debug(vl1.face, e1[0], xa1,ya1, e1[1], xa2,ya2)
			#debug(vl2.face, e2[0], xb1,yb1, e2[1], xb2,yb2)
			#debug(x, y)
			#debug(vl1.face, vl2.face, "intersect!")
			overlap = 1
			break
		    if overlap: break
		if overlap: break
		# Now try the epicentre trick, using winding
		# numbers.
		ex = ey = 0
		for x, y in vl1.vpos.values():
		    ex = ex + x
		    ey = ey + y
		ex = ex / len(vl1.vpos)
		ey = ey / len(vl1.vpos)
		winding = 0
		rx = vl1.bbox[2]-vl1.bbox[0] + vl2.bbox[2]-vl2.bbox[0]
		for e2 in faceedges[vl2.face]:
		    xb1, yb1 = vl2.vpos[e2[0]]
		    xb2, yb2 = vl2.vpos[e2[1]]
		    if not ((yb1<=ey and yb2>ey) or (yb1>ey and yb2<=ey)):
			continue # this edge is uninteresting
		    ret = crosspoint(ex,ey,ex+rx,ey,xb1,yb1,xb2,yb2)
		    if ret != None and ret[1] > ex:
			if yb1 <= ey:
			    winding = winding + 1
			else:
			    winding = winding - 1
		if winding:
		    #debug("winding!")
		    overlap = 1
		    break
	    if overlap: break
	if not overlap:
	    nfnew.append((n,p))
    nextface = nfnew
    #debug(nextface)

    # Select one out of the remainder, and go back round the loop.
    # Simplest thing here is to pick the one with the smallest
    # |pos|, to encourage the net to be roughly circular in shape.
    mindist2 = None
    best = None
    for n, p in nextface:
	placement = facepos[p].adjacent[n]
	dist2 = placement.pos[0] ** 2 + placement.pos[1] ** 2
	if mindist2 == None or dist2 < mindist2:
	    mindist2 = dist2
	    best = n, p
    if best == None:
	#debug("run out of faces to place")
	break
    n, p = best
    facepos[n] = facepos[p].adjacent[n]
    f = n
    #break

if len(unplaced) > 0:
    debug("!!!", len(unplaced), "faces still unplaced!")

# Print the net in a simplistic manner.
psprint("%!PS-Adobe-1.0")
psprint("%%Pages: 1")
psprint("%%EndComments")
psprint("%%Page: 1")
psprint("gsave")

# Compute the overall bbox.
xmin = ymin = xmax = ymax = None
for face, placement in facepos.items():
    if xmin == None or xmin > placement.bbox[0]: xmin = placement.bbox[0]
    if xmax == None or xmax < placement.bbox[2]: xmax = placement.bbox[2]
    if ymin == None or ymin > placement.bbox[1]: ymin = placement.bbox[1]
    if ymax == None or ymax < placement.bbox[3]: ymax = placement.bbox[3]
# Determine scale factor.
xscale = 550.0 / (xmax-xmin)
yscale = 550.0 / (ymax-ymin)
if xscale < yscale:
    scale = xscale
else:
    scale = yscale
psprint("288 500 translate")
psprint(scale, "dup scale")
# Now centre the bounding box at the origin.
psprint(-(xmax+xmin)/2, -(ymax+ymin)/2, "translate")
psprint(0.5 / scale, "setlinewidth 1 setlinejoin 1 setlinecap")
# Draw the faces.
for face, placement in facepos.items():
    psprint("newpath")
    cmd = "moveto"
    for v in faces[face]:
	psprint(placement.vpos[v][0], placement.vpos[v][1], cmd)
	cmd = "lineto"
    psprint("closepath stroke")

psprint("showpage grestore")
psprint("%%EOF")
