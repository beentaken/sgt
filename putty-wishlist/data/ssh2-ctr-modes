Summary: SSH-2 CTR modes
Difficulty: fun
Class: wish
Priority: low
Content-type: text/plain

The currently-expired Internet Draft, draft-ietf-secsh-newmodes-02.txt,
specifies a new symmetric-encryption mode for SSH that doesn't suffer
from the flaws described in ssh2-cbc-weakness.  Implementing these isn't
hard -- there's a patch below -- but we should perhaps at least wait until
the draft looks likely to become an RFC.

Index: sshaes.c
===================================================================
--- sshaes.c	(revision 5502)
+++ sshaes.c	(working copy)
@@ -1083,6 +1083,32 @@
     memcpy(ctx->iv, iv, sizeof(iv));
 }
 
+static void aes_sdctr(unsigned char *blk, int len, AESContext *ctx)
+{
+    word32 iv[4], b[4], tmp;
+    int i;
+
+    assert((len & 15) == 0);
+
+    memcpy(iv, ctx->iv, sizeof(iv));
+
+    while (len > 0) {
+	memcpy(b, iv, sizeof(b));
+	aes_encrypt(ctx, b);
+	for (i = 0; i < 4; i++) {
+	    tmp = GET_32BIT_MSB_FIRST(blk + 4 * i);
+	    PUT_32BIT_MSB_FIRST(blk + 4 * i, tmp ^ b[i]);
+	}
+	for (i = 3; i >= 0; i--)
+	    if ((iv[i] = (iv[i] + 1) & 0xffffffff) != 0)
+		break;
+	blk += 16;
+	len -= 16;
+    }
+
+    memcpy(ctx->iv, iv, sizeof(iv));
+}
+
 static void *aes_make_context(void)
 {
     return snew(AESContext);
@@ -1131,6 +1157,12 @@
     aes_decrypt_cbc(blk, len, ctx);
 }
 
+static void aes_ssh2_sdctr(void *handle, unsigned char *blk, int len)
+{
+    AESContext *ctx = (AESContext *)handle;
+    aes_sdctr(blk, len, ctx);
+}
+
 void aes256_encrypt_pubkey(unsigned char *key, unsigned char *blk, int len)
 {
     AESContext ctx;
@@ -1149,6 +1181,27 @@
     memset(&ctx, 0, sizeof(ctx));
 }
 
+static const struct ssh2_cipher ssh_aes128_ctr = {
+    aes_make_context, aes_free_context, aes_iv, aes128_key,
+    aes_ssh2_sdctr, aes_ssh2_sdctr,
+    "aes128-ctr",
+    16, 128, "AES-128 SDCTR"
+};
+
+static const struct ssh2_cipher ssh_aes192_ctr = {
+    aes_make_context, aes_free_context, aes_iv, aes192_key,
+    aes_ssh2_sdctr, aes_ssh2_sdctr,
+    "aes192-ctr",
+    16, 192, "AES-192 SDCTR"
+};
+
+static const struct ssh2_cipher ssh_aes256_ctr = {
+    aes_make_context, aes_free_context, aes_iv, aes256_key,
+    aes_ssh2_sdctr, aes_ssh2_sdctr,
+    "aes256-ctr",
+    16, 256, "AES-256 SDCTR"
+};
+
 static const struct ssh2_cipher ssh_aes128 = {
     aes_make_context, aes_free_context, aes_iv, aes128_key,
     aes_ssh2_encrypt_blk, aes_ssh2_decrypt_blk,
@@ -1199,11 +1252,14 @@
 };
 
 static const struct ssh2_cipher *const aes_list[] = {
+    &ssh_aes256_ctr,
     &ssh_aes256,
     &ssh_rijndael256,
     &ssh_rijndael_lysator,
+    &ssh_aes192_ctr,
     &ssh_aes192,
     &ssh_rijndael192,
+    &ssh_aes128_ctr,
     &ssh_aes128,
     &ssh_rijndael128,
 };
Index: sshblowf.c
===================================================================
--- sshblowf.c	(revision 5502)
+++ sshblowf.c	(working copy)
@@ -413,6 +413,32 @@
     ctx->iv1 = iv1;
 }
 
+static void blowfish_msb_sdctr(unsigned char *blk, int len,
+				     BlowfishContext * ctx)
+{
+    word32 b[2], iv0, iv1, tmp;
+
+    assert((len & 7) == 0);
+
+    iv0 = ctx->iv0;
+    iv1 = ctx->iv1;
+
+    while (len > 0) {
+	blowfish_encrypt(iv0, iv1, b, ctx);
+	tmp = GET_32BIT_MSB_FIRST(blk);
+	PUT_32BIT_MSB_FIRST(blk, tmp ^ b[0]);
+	tmp = GET_32BIT_MSB_FIRST(blk + 4);
+	PUT_32BIT_MSB_FIRST(blk + 4, tmp ^ b[1]);
+	if ((iv0 = (iv0 + 1) & 0xffffffff) == 0)
+	    iv1 = (iv1 + 1) & 0xffffffff;
+	blk += 8;
+	len -= 8;
+    }
+
+    ctx->iv0 = iv0;
+    ctx->iv1 = iv1;
+}
+
 static void blowfish_setkey(BlowfishContext * ctx,
 			    const unsigned char *key, short keybytes)
 {
@@ -542,6 +568,13 @@
     blowfish_msb_decrypt_cbc(blk, len, ctx);
 }
 
+static void blowfish_ssh2_sdctr(void *handle, unsigned char *blk,
+				      int len)
+{
+    BlowfishContext *ctx = (BlowfishContext *)handle;
+    blowfish_msb_sdctr(blk, len, ctx);
+}
+
 const struct ssh_cipher ssh_blowfish_ssh1 = {
     blowfish_ssh1_make_context, blowfish_free_context, blowfish_sesskey,
     blowfish_ssh1_encrypt_blk, blowfish_ssh1_decrypt_blk,
@@ -555,7 +588,15 @@
     8, 128, "Blowfish"
 };
 
+static const struct ssh2_cipher ssh_blowfish_ssh2_ctr = {
+    blowfish_make_context, blowfish_free_context, blowfish_iv, blowfish_key,
+    blowfish_ssh2_sdctr, blowfish_ssh2_sdctr,
+    "blowfish-ctr",
+    8, 256, "Blowfish SDCTR"
+};
+
 static const struct ssh2_cipher *const blowfish_list[] = {
+    &ssh_blowfish_ssh2_ctr,
     &ssh_blowfish_ssh2
 };
 
Index: sshdes.c
===================================================================
--- sshdes.c	(revision 5502)
+++ sshdes.c	(working copy)
@@ -744,6 +744,35 @@
     scheds->iv1 = iv1;
 }
 
+static void des_sdctr3(unsigned char *dest, const unsigned char *src,
+			     unsigned int len, DESContext * scheds)
+{
+    word32 b[2], iv0, iv1, tmp;
+    unsigned int i;
+
+    assert((len & 7) == 0);
+
+    iv0 = scheds->iv0;
+    iv1 = scheds->iv1;
+    for (i = 0; i < len; i += 8) {
+	des_encipher(b, iv0, iv1, &scheds[2]);
+	des_decipher(b, b[0], b[1], &scheds[1]);
+	des_encipher(b, b[0], b[1], &scheds[0]);
+	tmp = GET_32BIT_MSB_FIRST(src);
+	PUT_32BIT_MSB_FIRST(dest, tmp ^ b[0]);
+	src += 4;
+	dest += 4;
+	tmp = GET_32BIT_MSB_FIRST(src);
+	PUT_32BIT_MSB_FIRST(dest, tmp ^ b[0]);
+	src += 4;
+	dest += 4;
+	if ((iv0 = (iv0 + 1) & 0xffffffff) == 0)
+	    iv1 = (iv1 + 1) & 0xffffffff;
+    }
+    scheds->iv0 = iv0;
+    scheds->iv1 = iv1;
+}
+
 static void *des3_make_context(void)
 {
     return snewn(3, DESContext);
@@ -827,6 +856,12 @@
     des_cbc3_decrypt(blk, blk, len, keys);
 }
 
+static void des3_ssh2_sdctr(void *handle, unsigned char *blk, int len)
+{
+    DESContext *keys = (DESContext *) handle;
+    des_sdctr3(blk, blk, len, keys);
+}
+
 static void des_ssh2_encrypt_blk(void *handle, unsigned char *blk, int len)
 {
     DESContext *keys = (DESContext *) handle;
@@ -941,6 +976,13 @@
     8, 168, "triple-DES"
 };
 
+static const struct ssh2_cipher ssh_3des_ssh2_ctr = {
+    des3_make_context, des3_free_context, des3_iv, des3_key,
+    des3_ssh2_sdctr, des3_ssh2_sdctr,
+    "3des-ctr",
+    8, 168, "triple-DES SDCTR"
+};
+
 /*
  * Single DES in SSH-2. "des-cbc" is marked as HISTORIC in
  * draft-ietf-secsh-assignednumbers-04.txt, referring to
@@ -964,6 +1006,7 @@
 };
 
 static const struct ssh2_cipher *const des3_list[] = {
+    &ssh_3des_ssh2_ctr,
     &ssh_3des_ssh2
 };
 
