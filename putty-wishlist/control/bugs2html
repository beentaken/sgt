#! /usr/bin/perl
# $Id: bugs2html,v 1.34 2004/10/14 00:18:22 jacob Exp $

use FileHandle;
use POSIX;
use English;

$bugdir = "../data";

# config.pl should exist in the same directory as this script, and
# should define $htmldir (the full path to the directory HTML files
# should be written to) and $baseurl (the relative URL path to be
# added on the front of wishlist pages' links to main PuTTY pages).
# It can also redefine $bugdir if you really want to run bugs2html
# from somewhere other than the directory it's checked out into. A
# sample config.pl might read
#
#   $htmldir = "/home/simon/www/putty/wishlist";
#   $baseurl = "..";
#
require "./config.pl";

# This array maps releases to snapshot dates - it's used to
# automatically mark bugs which were fixed before the relevant
# snapshot date as also being fixed in a release.
# (It's only used for recent releases - old ones are all
# be explicitly marked in the wishlist data. Obviously branch
# releases don't go here either.)
@releases = (
    [ "0.54",   "2004-02-12" ],
    [ "0.55",   "2004-08-02" ]
);

%classdesc =
    ('vulnerability' => "This is a security vulnerability.",
     'bug'	=> "This is clearly an actual problem we want fixed.",
     'semi-bug'	=> "This might or might not be a bug, depending on your " .
                   "precise definition of what a bug is.",
     'wish'	=> "This is a request for an enhancement.");

%prioritydesc =
    ('high'	=> "This should be fixed in the next release.",
     'medium'	=> "This should be fixed one day.",
     'low'	=> "We aren't sure whether to fix this or not.",
     'never'	=> "We don't ever intend to fix this.");

%difficultydesc =
    ('fun'	=> "Just needs tuits, and not many of them.",
     'tricky'	=> "Needs many tuits.",
     'taxing'	=> "Needs external things we don't have (standards, users " .
		   "etc)",
     'mayhem'	=> "Probably impossible");

my @headers = ();
my $prlevel = my $level = 0;

my %bugs = ();
$INPUT_RECORD_SEPARATOR = undef;
foreach $bugfile (glob("$bugdir/*")) {
    next unless -f $bugfile;
    open(BF, "< $bugfile") or die "$bugfile: $!";
    my $data = <BF>;
    close BF;
    my ($bugname) = $bugfile =~ m{([^/]*)$};
    my ($hdr, $body) = $data =~ /^(.*?\n)\n(.*)$/s;
    $hdr =~ s/\n\s+/ /g;
    my @hdrs = split /\n/, $hdr;
    my %hdrs = map { /^(\S*?):\s*(.*)$/; (lc $1, $2) } @hdrs;
    $bugs{$bugname} = {
        "hdrs" => \%hdrs,
        "body" => $body,
        "cvs"  => `cvs status $bugfile`
    };
    add_release_fixes($bugname);
}

foreach my $bug (keys %bugs) {
    bug2html($bug);
}

my @fullbuglist = keys %bugs;

my $site = $baseurl;
($site =~ s#^http://([^/]*).*$#$1#) or ($site = "www.chiark.greenend.org.uk");

open(INDEX, "> $htmldir/index.html") or die "$htmldir/index.html: $!";

nest(<<EOF);
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD>
<TITLE>PuTTY Known Bugs and Wish List</TITLE>
<link rel="stylesheet" type="text/css" href="$baseurl/sitestyle.css" title="PuTTY Home Page Style">
</HEAD>
<BODY>
<h1 align=center>PuTTY Known Bugs and Wish List</h1>

<p align=center>
<a href="$baseurl/">Home</a> |
<a href="$baseurl/licence.html">Licence</a> |
<a href="$baseurl/faq.html">FAQ</a> |
<a href="$baseurl/docs.html">Docs</a> |
<a href="$baseurl/download.html">Download</a> |
<a href="$baseurl/keys.html">Keys</a> |
<a href="$baseurl/links.html">Links</a><br>
<a href="$baseurl/mirrors.html">Mirrors</a> |
<a href="$baseurl/maillist.html">Updates</a> |
<a href="$baseurl/feedback.html">Feedback</a> |
<a href="$baseurl/changes.html">Changes</a> |
<b>Wishlist</b> |
<a href="$baseurl/team.html">Team</a></p>

<p>
This is the list of bugs that need fixing, and features that want
adding, to PuTTY. The <a href="#pending">`pending'</a> list represents
things that have not been done to the current <em>development</em>
code; items marked as `fixed' may not yet be in the latest release.

<p>
If you do not see a feature here, it's also worth checking the
<a href="$baseurl/changes.html">Changes page</a>
before mailing us to ask for the feature; it might already have
been added.

<p>
The Debian bug-tracking system also accrues bug reports and feature
requests relating to the
<a href="http://packages.qa.debian.org/p/putty.html">Debian package</a>
of the Unix port.

<p>
Search the wishlist:
<form method="get" action="http://www.google.com/search">
<table><tr><td>
<a href="http://www.google.com/"><img src="http://www.google.com/logos/Logo_40wht.gif" border="0" alt="Google"></a>
</td>
<td>
<input type="text" name="q" size="50" maxlength="255" value="&#043;&#034;last revision of this bug record&#034;&#032;">
<input type="submit" name="btnG" value="Google Search">
<input type="hidden" name="domains" value="$site"><br>
<input type="radio" name="sitesearch" value="">WWW
<input type="radio" name="sitesearch" value="$site" checked>$site<br>
</td></tr></table>
</form>

EOF

nest(<<EOF);
<h2><a name="fixed">Recently fixed</a></h2>

<p>
These are items we believe we have already addressed. See also the
<a href="$baseurl/changes.html">Changes page</a>.

EOF

# Classify fixed bugs by when they were fixed
my %fixedvers = ();
foreach my $bug (grep(exists($bugs{$_}->{"hdrs"}->{"fixed-in"}), @fullbuglist)) {
    my $class;
    foreach my $ver (split(' ', $bugs{$bug}->{"hdrs"}->{"fixed-in"})) {
        $newclass = classifyver($ver);
        $class = $newclass if (!defined($class) ||
                               compareverclass($class, $newclass) > 0);
    }
    $fixedvers{$class} = [] unless defined($fixedvers{$class});
    push @{$fixedvers{$class}}, $bug;
}

# Now spit them out in order.
foreach my $class (sort compareverclass_s (keys %fixedvers)) {

    nest(<<EOF);
<h3>Fixed in $class</h3>
<ul>
EOF

    nest(<<EOF);
<li>Security vulnerabilities
<ul>
EOF

    my @tmp = grep(($bugs{$_}->{hdrs}->{class} eq 'vulnerability'),
                   @{$fixedvers{$class}});
    subtractbugs(\@fullbuglist, printbugs(\@tmp, 2));

    unnest("</ul>\n");

    nest(<<EOF);
<li>Bugs (and semi-bugs)
<ul>
EOF

    my @tmp = grep(($bugs{$_}->{hdrs}->{class} eq 'bug' ||
                    $bugs{$_}->{hdrs}->{class} eq 'semi-bug'),
                   @{$fixedvers{$class}});
    subtractbugs(\@fullbuglist, printbugs_diff_ordered(\@tmp));

    unnest("</ul>\n");

    nest(<<EOF);
<li>Wishes
<ul>
EOF

    my @tmp = grep(($bugs{$_}->{hdrs}->{class} eq 'wish'),
                   @{$fixedvers{$class}});
    subtractbugs(\@fullbuglist, printbugs_diff_ordered(\@tmp));

    unnest("</ul>\n");

    unnest("</ul>\n");

}

unnest("");

nest(<<EOF);
<h2><a name="pending">Pending</a></h2>

<p>
These are bugs still be be fixed and features remaining to be
implemented.

EOF

# If there are any of these visible, chances are that we haven't
# considered them important enough to make a new release for.
nest(<<EOF);
<h3><a name="vulns">Vulnerabilities</a></h3>

<p>
These are potential or actual vulnerabilities in the code that may
allow an attacker to gain some level of unauthorised access.
<ul>
EOF

my @vulnlist = grep(($bugs{$_}->{hdrs}->{class} eq 'vulnerability'),
                    @fullbuglist);
subtractbugs(\@fullbuglist, printbugs(\@vulnlist, 2));

unnest("</ul>\n");

nest(<<EOF);
<h3><a name="bugs">Bugs</a></h3>

<p>
These items are clearly actual problems and I want them fixed.
<ul>
EOF

my @buglist = grep(($bugs{$_}->{hdrs}->{class} eq 'bug'), @fullbuglist);
subtractbugs(\@fullbuglist, \@buglist);

my @tmp = grep(($bugs{$_}->{hdrs}->{priority} eq 'high'), @buglist);
subtractbugs(\@buglist, printbugs(\@tmp, 1));

printbugs(\@buglist);

unnest("</ul>\n");

nest(<<EOF);
<h3>Semi-bugs</h3>

<p>
These are things which might be bugs or might not, depending on your
precise definition of what a bug is.

<ul>
EOF

my @semibuglist = grep(($bugs{$_}->{hdrs}->{class} eq 'semi-bug'),
                       @fullbuglist);
subtractbugs(\@fullbuglist, \@semibuglist);

my @tmp = grep(($bugs{$_}->{hdrs}->{priority} eq 'high'), @semibuglist);
subtractbugs(\@semibuglist, printbugs(\@tmp, 1));

printbugs(\@semibuglist);

unnest("</ul>\n");

nest(<<EOF);
<h3>Wishlist</h3>

<p>
These are things that have been requested by users or which seem to me like
a good idea.  Not all of these are likely to be implemented without outside
help, and some of them will positively never be implemented.

EOF

my @wishlist = grep(($bugs{$_}->{hdrs}->{class} eq 'wish'), @fullbuglist);

nest(<<EOF);
<p>
Features we'd like to include in the next release:

<ul>
EOF

my @tmp = grep(($bugs{$_}->{hdrs}->{priority} eq 'high'),@wishlist);
subtractbugs(\@fullbuglist, printbugs(\@tmp));

unnest("</ul>\n");

nest(<<EOF);
<p>
Plausible features we hope to get round to adding at some point:

<ul>
EOF

my @tmp = grep(($bugs{$_}->{hdrs}->{priority} eq 'medium'),@wishlist);

foreach my $difficulty ("fun", "tricky", "taxing", "mayhem") {
    nest(<<EOF);
<li>"$difficulty": $difficultydesc{$difficulty}
<ul>
EOF
    my @tmp2 = grep(($bugs{$_}->{hdrs}->{difficulty} eq $difficulty),@tmp);
    subtractbugs(\@fullbuglist, printbugs(\@tmp2));

    unnest("</ul>\n");
}

unnest("</ul>\n");

nest(<<EOF);
<p>
Features we're not sure about, or which probably won't get added
unless someone else does the hard work:

<ul>
EOF

my @tmp = grep(($bugs{$_}->{hdrs}->{priority} eq 'low'),@wishlist);

foreach my $difficulty ("fun", "tricky", "taxing", "mayhem") {
    nest(<<EOF);
<li>"$difficulty": $difficultydesc{$difficulty}
<ul>
EOF
    my @tmp2 = grep(($bugs{$_}->{hdrs}->{difficulty} eq $difficulty),@tmp);
    subtractbugs(\@fullbuglist, printbugs(\@tmp2));

    unnest("</ul>\n");
}

unnest("</ul>\n");

nest(<<EOF);
<h4>Non-wish list</h4>

<p>
These are features we are actively opposed to seeing in PuTTY. Don't
bother writing them and sending them to us! If you think you have a
good argument why they would be good, feel free to plead for them, but
generally I'll already have a good reason not to do them.

<ul>
EOF

my @tmp = grep(($bugs{$_}->{hdrs}->{priority} eq 'never'),@wishlist);
subtractbugs(\@fullbuglist, printbugs(\@tmp));

unnest("</ul>\n");

unnest("");

unnest("");

nest(<<EOF);
<h2>Uncategorised</h2>

<p>
Usually items we don't know enough about, or haven't yet thought about
enough, to fully classify.

<ul>
EOF

printbugs(\@fullbuglist);

unnest("</ul>\n");

unnest(<<EOF);
<p><hr>If you want to comment on this web site, see the
<a href="$baseurl/feedback.html">Feedback page</a>.
<br>
(generated by bugs2html at
@{[POSIX::strftime("%a, %d %b %Y, %H:%M:%S %Z", gmtime)]})
</BODY></HTML>
EOF

close INDEX;

# Print bugs ordered by difficulty.
sub printbugs_diff_ordered {
    my ($buglist) = @_;
    my @tmp = @$buglist;
    my @hardbugs = grep((defined($bugs{$_}->{hdrs}->{difficulty}) && 
                         $bugs{$_}->{hdrs}->{difficulty} ne "fun"), @tmp);
    subtractbugs(\@tmp, printbugs(\@hardbugs, 1));
    printbugs(\@tmp);
    return $buglist;
}

sub nest {
    my($header) = @_;
    push @headers, $header;
    $level++;
}

sub print_hdrs {
    for (my $i = $prlevel; $i < $level; $i++) {
        print INDEX $headers[$i];
    }
    $prlevel = $level;
}

sub unnest {
    my($trailer) = @_;
    $level--;
    if ($prlevel > $level) {
        print INDEX $trailer;
        $prlevel = $level;
    }
    pop @headers;
}


sub bug2html {
    my($bugname) = @_;
    my $hdrs = $bugs{$bugname}->{"hdrs"};
    my $body = $bugs{$bugname}->{"body"};
    my $cvsstat = $bugs{$bugname}->{"cvs"};
    my $class = ($hdrs->{class} or "artifact");

    open(HTML, "> $htmldir/$bugname.html") or die "$htmldir/$bugname.html: $!";
    print HTML <<EOH;
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD>
<TITLE>PuTTY $class $bugname</TITLE>
<link rel="stylesheet" type="text/css" href="$baseurl/sitestyle.css" title="PuTTY Home Page Style">
</HEAD>
<BODY>
<h1 align=center>PuTTY $class $bugname</h1>

<p align=center>
<a href="$baseurl/">Home</a> |
<a href="$baseurl/licence.html">Licence</a> |
<a href="$baseurl/faq.html">FAQ</a> |
<a href="$baseurl/docs.html">Docs</a> |
<a href="$baseurl/download.html">Download</a> |
<a href="$baseurl/keys.html">Keys</a> |
<a href="$baseurl/links.html">Links</a><br>
<a href="$baseurl/mirrors.html">Mirrors</a> |
<a href="$baseurl/maillist.html">Updates</a> |
<a href="$baseurl/feedback.html">Feedback</a> |
<a href="$baseurl/changes.html">Changes</a> |
<b><a href="index.html">Wishlist</a></b> |
<a href="$baseurl/team.html">Team</a></p>

EOH

    foreach $h (keys %$hdrs) {
	my($desc);
	$h eq "content-type" && next;
	$h eq "class" && ($desc = $classdesc{$hdrs->{$h}});
	$h eq "priority" && ($desc = $prioritydesc{$hdrs->{$h}});
	$h eq "difficulty" && ($desc = $difficultydesc{$hdrs->{$h}});
	print HTML "<b>$h</b>: ";
        if ($h eq "depends") {
            print HTML map "<a href=\"$_.html\">$_</a>", (split ' ', $hdrs->{$h});
	} elsif (defined($desc)) {
	    print HTML "<i>@{[$hdrs->{$h}]}:</i> $desc";
	} else {
	    print HTML $hdrs->{$h};
	}
	print HTML qq"<br>\n";
    }

    if ($hdrs->{'content-type'} =~ "^text/x-html-body") {
	print HTML $body;
    } else {
	$body =~ s/&/&amp;/g;
	$body =~ s/</&lt;/g;
	$body =~ s/>/&gt;/g;
	print HTML qq[<p><pre>$body</pre>];
    }

    print HTML <<EOF;
<p><a href="http://cvs.tartarus.org/putty-wishlist/data/$bugname">
Audit trail</a> for this $class.
<p><hr>If you want to comment on this web site, see the
<a href="$baseurl/feedback.html">Feedback page</a>.
<br>
EOF
    $time = "(generated by bugs2html at\n" .
      POSIX::strftime("%a, %d %b %Y, %H:%M:%S %Z", gmtime) . ")\n";
    if ($cvsstat ne "" and
	$cvsstat =~ /^\s+Working revision:\s+\S+\s+(.*\S)\s*$/m) {
	$time = "(last revision of this bug record was at $1)\n";
    } else {
    }
    print HTML $time . "</BODY></HTML>\n";

    close(HTML);
}

# For a given bug, look at the snapshots it was fixed in and work
# out whether that also implies it's been fixed in a release.
sub add_release_fixes {
    my ($bug) = @_;
    my @extra_fixed = ();
    return unless exists ($bugs{$bug}->{"hdrs"}->{"fixed-in"});
    foreach my $ver (split(' ', $bugs{$bug}->{"hdrs"}->{"fixed-in"})) {
        next unless $ver =~ m/^\d\d\d\d-\d\d-\d\d$/;
        map {
            my ($rel, $rel_date) = @$_;
            # Textual comparison works for snapshot dates.
            # We add the release version in parentheses so that it's
            # distinguishable from one in the source data.
            push @extra_fixed, "($rel)" if ($ver le $rel_date);
        } @releases;
    }
    $bugs{$bug}->{"hdrs"}->{"fixed-in"} =
        join " ", $bugs{$bug}->{"hdrs"}->{"fixed-in"}, @extra_fixed;
}

# Given a version string, return a canonical textual name
# describing it (equivalence class).
sub classifyver {
    my ($ver) = @_;
    $ver =~ s/^\((.*)\)$/$1/;   # remove "auto-generated" hint
    my $name;
    if   ($ver =~ m/^\d{4}-\d{2}-\d{2}$/) { $name = "current snapshots"; }
    else                                  { $name = "release " . $ver; }
    return $name;
}

# Compare function for equivalence classes as returned by classifyver
# (version for use with sort)
sub compareverclass_s {
    if ($a eq $b) {
        return 0;
    } elsif ($a eq "current snapshots") {
        return 1;
    } elsif ($b eq "current snapshots") {
        return -1;
    } else {
        my ($aver, $bver) = ($a, $b);
        map s/^release //, ($aver, $bver);
        # Debian version compare algorithm (packaging manual 3.1.1.1)
        my $cmp = 0;
        while ($cmp == 0) {
            my ($apre, $bpre);

            ($apre, $aver) = ($aver =~ m/^(\D*)(.*)$/);
            ($bpre, $bver) = ($bver =~ m/^(\D*)(.*)$/);
            # Not quite the right collating order...
            $cmp = ($apre cmp $bpre);
            last if ($cmp != 0);

            ($apre, $aver) = ($aver =~ m/^(\d*)(.*)$/);
            ($bpre, $bver) = ($bver =~ m/^(\d*)(.*)$/);
            $cmp = ($apre <=> $bpre);

        }
        return $cmp;
    }
}

# Wrapper for compareverclass_s with sensible argument passing
sub compareverclass {
    ($a, $b) = @_;
    return compareverclass_s();
}

sub printbugs {
    my ($buglist, $emph) = @_;
    $emph = 0 unless defined($emph);
    return unless @$buglist;
    print_hdrs();
    foreach $bug (sort @$buglist) {
        print INDEX bugdesc($bug, $emph);
    }
    return $buglist;
}

sub subtractbugs {
    my ($from, $buglist) = @_;
    my %del = ();
    map { $del{$_}=1 } @$buglist;
    @$from = grep ((!exists($del{$_})), @$from);
    return $from;
}

sub bugdesc {
    my ($bugname, $emph) = @_;
    $emph = 0 unless defined($emph);
    if ($emph == 2) {
        return qq[<li><b><i><a href="$bugname.html">$bugname: ] .
               qq[$bugs{$bugname}->{hdrs}->{summary}</a></i></b>\n];
    } elsif ($emph == 1) {
        return qq[<li><b><a href="$bugname.html">$bugname: ] .
               qq[$bugs{$bugname}->{hdrs}->{summary}</a></b>\n];
    } else {
        return qq[<li><a href="$bugname.html">$bugname: ] .
               qq[$bugs{$bugname}->{hdrs}->{summary}</a>\n];
    }
}
