/*
 * cron.c - simple reminder-generating cron job
 */

#include <stdio.h>
#include <assert.h>
#include "caltrap.h"

struct cron_ctx {
    char *cmd, *tfmt, *d1fmt, *t1fmt, *d2fmt, *t2fmt;
    Date sd, ed;
    Time st, et;
    FILE *fp;
};

static void cron_callback(void *vctx, struct entry *ent)
{
    struct cron_ctx *ctx = (struct cron_ctx *)vctx;
    char *dfmt, *tfmt;

    if (ent->type != T_EVENT)
        return;                        /* only EVENTs need cron reminders */

    if (datetime_cmp(ent->sd, ent->st, ctx->sd, ctx->st) < 0) {
        Duration d;

        /*
         * This event started before the beginning of the reminder
         * period. So if it isn't repeating, we should ignore it.
         */
        if (ent->period == 0)
            return;
        /*
         * Otherwise, find its first occurrence after the beginning
         * of the reminder period...
         */
        d = datetime_diff(ctx->sd, ctx->st, ent->sd, ent->st);
        d = ((d + ent->period - 1) / ent->period) * ent->period;
        add_to_datetime(&ent->sd, &ent->st, d);
        assert(datetime_cmp(ent->sd, ent->st, ctx->sd, ctx->st) >= 0);
        /*
         * ... and see whether that comes before the _end_ of the
         * reminder period.
         */
        if (datetime_cmp(ent->sd, ent->st, ctx->ed, ctx->et) >= 0)
            return;
    }

    if (ctx->fp == NULL) {
        ctx->fp = popen(ctx->cmd, "w");
        if (ctx->fp == NULL)
            fatalerr_cronpipe();

        fprintf(ctx->fp,
                "This is an automated calendar notification"
                " generated by Caltrap.\n"
                "Listing your calendar entries in the next %s,\n"
                "i.e. between %s %s and %s %s:\n\n",
                ctx->tfmt,
                ctx->d1fmt, ctx->t1fmt, ctx->d2fmt, ctx->t2fmt);
    }

    dfmt = format_date_full(ent->sd);
    tfmt = format_time(ent->st);
    fprintf(ctx->fp, "%s %s %s\n", dfmt, tfmt, ent->description);
    sfree(dfmt);
    sfree(tfmt);
}

void caltrap_cron(int nargs, char **args, int nphysargs)
{
    Date d, d2;
    Time t, t2;
    Duration diff;
    struct cron_ctx ctx;

    if (nargs != 2)
	fatalerr_cronargno();
    assert(nargs <= nphysargs);

    diff = parse_duration(args[0]);
    if (diff == INVALID_DURATION)
        fatalerr_duration(args[0]);

    now(&d, &t);
    d2 = d;
    t2 = t;
    add_to_datetime(&d2, &t2, diff);

    ctx.fp = NULL;
    ctx.sd = d;
    ctx.st = t;
    ctx.ed = d2;
    ctx.et = t2;
    ctx.cmd = args[1];
    ctx.tfmt = format_duration(diff);
    ctx.d1fmt = format_date_full(d);
    ctx.t1fmt = format_time(t);
    ctx.d2fmt = format_date_full(d2);
    ctx.t2fmt = format_time(t2);

    db_list_entries(d, t, d2, t2, cron_callback, &ctx);

    sfree(ctx.tfmt);
    sfree(ctx.d1fmt);
    sfree(ctx.t1fmt);
    sfree(ctx.d2fmt);
    sfree(ctx.t2fmt);
    if (ctx.fp)
        pclose(ctx.fp);
}
