#!/usr/bin/env python

import sys
import os
import re
import string
import types
import md5

# First, the sensible way to deal with a pathname is to split it
# into pieces at the slashes and thereafter treat it as a list.
def splitpath(s):
    list = string.split(s, "/")
    # Simplest way to remove all empty elements!
    try:
	while 1:
	    list.remove("")
    except ValueError:
	pass
    return list

def joinpath(list, prefix=""):
    return prefix + string.join(list, "/")

def catpath(path1, path2, prefix=""):
    return joinpath(splitpath(path1) + splitpath(path2), prefix)

# Decide whether a pathname is interesting or not.
class InterestingPaths:
    def __init__(self, args):
	self.res = []
	for a in args:
	    self.res.append(re.compile(a))
    def interesting(self, path):
	a = splitpath(path)
	assert len(a) > 0
	for r in self.res:
	    if r.match(a[0]):
		return 1
	return 0

# Now here's a class that tracks a directory tree, storing a
# user-provided value at each node.
#
# We expect to be reading a valid SVN dump file output by SVN
# itself, so I currently feel no particular obligation to do
# user-friendly error reporting. Assertion failures or Python
# exceptions are perfectly adequate, since errors should only show
# up during development of this script.
def copy(tree):
    if type(tree) != types.DictType:
	return tree
    ret = {}
    for key, val in tree.items():
	if len(val) == 2:
	    ret[key] = (val[0], copy(val[1]))
	else:
	    ret[key] = val
    return ret

class DirTree:
    # Each directory within the tree is represented by a
    # dictionary, with filenames as keys. Entries representing
    # subdirectories have a tuple containing (userdata,
    # next-level-dict) as their value; entries representing files
    # just have a 1-tuple containing (userdata,).
    def __init__(self, clone=None):
	"Initialise an empty dir tree, or clone from `clone' if present."
	if clone == None:
	    self.topdir = {}
	else:
	    self.topdir = copy(clone.topdir)

    def _searchto(self, path):
	ps = splitpath(path)
	d = self.topdir
	for s in ps[:-1]:
	    d = d[s][1]
	s = ps[-1]
	return d, s

    def mkdir(self, path, data=None):
	d, s = self._searchto(path)
	assert not d.has_key(s)
	d[s] = (data, {})

    def mkfile(self, path, data=None):
	d, s = self._searchto(path)
	assert not d.has_key(s)
	d[s] = (data,)

    def find(self, path):
	d, s = self._searchto(path)
	assert d.has_key(s)
	return d[s][0]

    def change(self, path, data=None):
	d, s = self._searchto(path)
	assert d.has_key(s)
	d[s] = (data,) + d[s][1:]

    def filetype(self, path):
	d, s = self._searchto(path)
	assert d.has_key(s)
	if len(d[s]) > 1:
	    return "d"
	else:
	    return "f"

    def delete(self, path):
	d, s = self._searchto(path)
	assert d.has_key(s)
	del d[s]

    def filenames(self, path):
	d, s = self._searchto(path + "/flibble")
	return d.keys()

    def copy(self):
	return DirTree(self)

# A class and some functions to handle a single lump of
# RFC822-ish-headers-plus-data read from an SVN dump file.

class Lump:
    def __init__(self):
	self.hdrlist = []
	self.hdrdict = {}
	self.prop = ""
	self.text = ""
	self.extant = 1
	self.props = [[], {}]
    def sethdr(self, key, val):
	if not self.hdrdict.has_key(key):
	    self.hdrlist.append(key)
	self.hdrdict[key] = val
    def delhdr(self, key):
	if self.hdrdict.has_key(key):
	    del self.hdrdict[key]
	    self.hdrlist.remove(key)
    def propparse(self):
	index = 0
	while 1:
	    if self.prop[index:index+2] == "K ":
		wantval = 1
	    elif self.prop[index:index+2] == "D ":
		wantval = 0
	    elif self.prop[index:index+9] == "PROPS-END":
		break
	    else:
		raise "Unrecognised record in props section"
	    nlpos = string.find(self.prop, "\n", index)
	    assert nlpos > 0
	    namelen = string.atoi(self.prop[index+2:nlpos])
	    assert self.prop[nlpos+1+namelen] == "\n"
	    name = self.prop[nlpos+1:nlpos+1+namelen]
	    index = nlpos+2+namelen
	    if wantval:
		assert self.prop[index:index+2] == "V "
		nlpos = string.find(self.prop, "\n", index)
		assert nlpos > 0
		proplen = string.atoi(self.prop[index+2:nlpos])
		assert self.prop[nlpos+1+proplen] == "\n"
		prop = self.prop[nlpos+1:nlpos+1+proplen]
		index = nlpos+2+proplen
	    else:
		prop = None
	    self.props[0].append(name)
	    self.props[1][name] = prop
    def setprop(self, key, val):
	if not self.props[1].has_key(key):
	    self.props[0].append(key)
	self.props[1][key] = val
    def delprop(self, key):
	if self.props[1].has_key(key):
	    del self.props[1][key]
	    self.props[0].remove(key)
    def correct_headers(self):
	# First reconstitute the properties block.
	self.prop = ""
	if len(self.props[0]) > 0:
	    for key in self.props[0]:
		val = self.props[1][key]
		if val == None:
		    self.prop = self.prop + "D %d" % len(key) + "\n" + key + "\n"
		else:
		    self.prop = self.prop + "K %d" % len(key) + "\n" + key + "\n"
		    self.prop = self.prop + "V %d" % len(val) + "\n" + val + "\n"
	    self.prop = self.prop + "PROPS-END\n"
	# Now fix up the content length headers.
	if len(self.prop) > 0:
	    self.sethdr("Prop-content-length", str(len(self.prop)))
	else:
	    self.delhdr("Prop-content-length")
	if len(self.text) > 0:
	    self.sethdr("Text-content-length", str(len(self.text)))
	    m = md5.new()
	    m.update(self.text)
	    self.sethdr("Text-content-md5", m.hexdigest())
	else:
	    self.delhdr("Text-content-length")
	    self.delhdr("Text-content-md5")
	if len(self.prop) > 0 or len(self.text) > 0:
	    self.sethdr("Content-length", str(len(self.prop)+len(self.text)))
	else:
	    self.delhdr("Content-length")

def read_rfc822_headers(f):
    ret = Lump()
    while 1:
	s = f.readline()
	if s == "":
	    return None # end of file
	if s == "\n":
	    if len(ret.hdrlist) > 0:
		break # newline after headers ends them
	    else:
		continue # newline before headers is simply ignored
	if s[-1:] == "\n": s = s[:-1]
	colon = string.find(s, ":")
	assert colon > 0
	assert s[colon:colon+2] == ": "
	key = s[:colon]
	val = s[colon+2:]
	ret.sethdr(key, val)
    return ret

def read_lump(f):
    lump = read_rfc822_headers(f)
    if lump == None:
	return None
    pcl = string.atoi(lump.hdrdict.get("Prop-content-length", "0"))
    tcl = string.atoi(lump.hdrdict.get("Text-content-length", "0"))
    if pcl > 0:
	lump.prop = f.read(pcl)
	lump.propparse()
    if tcl > 0:
	lump.text = f.read(tcl)
    return lump

def write_lump(f, lump):
    if not lump.extant:
	return
    lump.correct_headers()
    for key in lump.hdrlist:
	val = lump.hdrdict[key]
	f.write(key + ": " + val + "\n")
    f.write("\n")
    f.write(lump.prop)
    f.write(lump.text)
    if lump.hdrdict.has_key("Prop-content-length") or \
    lump.hdrdict.has_key("Text-content-length") or \
    lump.hdrdict.has_key("Content-length"):
	f.write("\n")

# Higher-level class that makes use of the above to filter dump
# file fragments a whole revision at a time.

class Filter:
    def __init__(self, paths):
	self.dirtree = DirTree()
	self.revisions = {}
	self.paths = paths

    def docopy(self, stree, srev, spath, dtree, dpath, contents=None):
	# If the destination directory is uninteresting, we don't
	# need to write anything to `contents' ever.
	if contents != None and not self.paths.interesting(dpath):
	    #sys.stderr.write("%s->%s: copy to uninteresting location\n" % (spath, dpath));
	    contents = None

	# Simple case: a copy from an interesting directory is done
	# in the normal way, and then we stop writing to `contents'
	# because there's no need to log the subsidiary copies
	# explicitly.
	if contents != None and self.paths.interesting(spath):
	    #sys.stderr.write("%s->%s: copy between interesting locations\n" % (spath, dpath));
	    lump = Lump()
	    lump.sethdr("Node-path", dpath)
	    lump.sethdr("Node-action", "add")
	    lump.sethdr("Node-copyfrom-rev", str(srev))
	    lump.sethdr("Node-copyfrom-path", spath)
	    contents.append(lump)
	    contents = None

	typ = stree.filetype(spath)
	if typ == "f":
	    dtree.mkfile(dpath)
	    # Difficult case: we must copy this file explicitly.
	    if contents != None:
		#sys.stderr.write("%s->%s: file copy needing full data\n" % (spath, dpath));
		lump = Lump()
		lump.sethdr("Node-path", dpath)
		lump.sethdr("Node-kind", "file")
		lump.sethdr("Node-action", "add")
		lump.props = stree.find(spath)
		f = os.popen("svnlook cat -r" + str(srev) + \
		" " + repos + " " + spath, "r")
		lump.text = f.read()
		f.close()
		contents.append(lump)
	else:
	    dtree.mkdir(dpath)
	    # Difficult case: we must create this directory explicitly.
	    if contents != None:
		#sys.stderr.write("%s->%s: dir copy needing explicit mkdir\n" % (spath, dpath));
		lump = Lump()
		lump.sethdr("Node-path", dpath)
		lump.sethdr("Node-kind", "dir")
		lump.sethdr("Node-action", "add")
		lump.props = stree.find(spath)
		contents.append(lump)
	    files = stree.filenames(spath)
	    for file in files:
		self.docopy(stree, srev, catpath(spath, file), \
		dtree, catpath(dpath, file), contents)

    def tweak(self, revhdr, contents):
	contents2 = []
	for lump in contents:
	    action = lump.hdrdict["Node-action"]
	    path = lump.hdrdict["Node-path"]
	    #sys.stderr.write("%s %s\n" % (action, path))
	    if action == "add":
		if lump.hdrdict.has_key("Node-copyfrom-path"):
		    srcrev = string.atoi(lump.hdrdict["Node-copyfrom-rev"])
		    srcpath = lump.hdrdict["Node-copyfrom-path"]
		    # Must find the source dir subtree, _as it
		    # existed in the given revision_, and copy it
		    # in full.
		    srctree = self.revisions[srcrev]
		    self.docopy(srctree, srcrev, srcpath, \
		    self.dirtree, path, contents2)
		    if len(lump.text) > 0 and self.paths.interesting(path):
			# This was a copyfrom _plus_ some sort of
			# delta or new contents, which means that
			# having done the copy we now also need a
			# change record providing the new contents.
			lump.sethdr("Node-action", "change")
			lump.delhdr("Node-copyfrom-rev")
			lump.delhdr("Node-copyfrom-path")
			contents2.append(lump)
		elif lump.hdrdict["Node-kind"] == "dir":
		    self.dirtree.mkdir(path, lump.props)
		    if self.paths.interesting(path):
			contents2.append(lump)
		else:
		    self.dirtree.mkfile(path, lump.props)
		    if self.paths.interesting(path):
			contents2.append(lump)
	    elif action == "change":
		self.dirtree.change(path, lump.props)
		if self.paths.interesting(path):
		    contents2.append(lump)
	    elif action == "delete":
		self.dirtree.delete(path)
		if self.paths.interesting(path):
		    contents2.append(lump)

	# Must now clone the entire dir tree and store it in a
	# revisions array, in case a future copy needs to access
	# this version of the tree.
	revnum = string.atoi(revhdr.hdrdict["Revision-number"])
	self.revisions[revnum] = self.dirtree.copy()

	# Change the contents array.
	contents[:] = contents2

	# If we've just removed everything in this revision, leave
	# out some revision properties as well.
	if (len(contents) == 0):
	    revhdr.delprop("svn:log")
	    revhdr.delprop("svn:author")
	    revhdr.delprop("svn:date")

fr = sys.stdin
fw = sys.stdout

repos = sys.argv[1]
paths = InterestingPaths(sys.argv[2:])

# Pass the dump-file header through unchanged.
lump = read_lump(fr)
while not lump.hdrdict.has_key("Revision-number"):
    write_lump(fw, lump)
    lump = read_lump(fr)

revhdr = lump

filt = Filter(paths)

while revhdr != None:
    # Read revision header.
    assert revhdr.hdrdict.has_key("Revision-number")
    contents = []
    # Read revision contents.
    while 1:
	lump = read_lump(fr)
	if lump == None or lump.hdrdict.has_key("Revision-number"):
	    newrevhdr = lump
	    break
	contents.append(lump)

    # Alter the contents of the revision.
    filt.tweak(revhdr, contents)

    # Write out revision.
    write_lump(fw, revhdr)
    for lump in contents:
	write_lump(fw, lump)

    # And loop round again.
    revhdr = newrevhdr

fr.close()
fw.close()
