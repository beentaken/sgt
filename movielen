#!/usr/bin/python 

# Report the playback duration of a movie file.
#
# I hope to gradually enhance this to cope with any container
# formats I might come across that I didn't already know about.

import sys
import zlib

verbose = 0

def decode_leu(s):
    "Interpret s as a little-endian binary unsigned number."
    ret = 0L
    while len(s) > 0:
	n = ord(s[-1])
	s = s[:-1]
	ret = ret * 256L + n
    return ret

def decode_beu(s):
    "Interpret s as a big-endian binary unsigned number."
    ret = 0L
    while len(s) > 0:
	n = ord(s[0])
	s = s[1:]
	ret = ret * 256L + n
    return ret

def mpegtimestamp(data):
    # See comments further down for details of this completely
    # bizarre format.
    data = decode_beu(data)
    data = data >> 1 # eat unused bottom bit
    data = (data & 0x7FFF) | ((data >> 1) & ~0x7FFF) # eat unused bit 15
    data = (data & 0x3FFFFFFF) | ((data >> 1) & ~0x3FFFFFFF) # eat bit 30
    data = data & 0x1FFFFFFFFL # eat everything above bit 33
    return data

def printduration(name, duration):
    seconds = long(duration)
    minutes = seconds / 60
    seconly = seconds % 60
    hours = minutes / 60
    minutes = minutes % 60
    if hours:
	nicetime = "%d:%02d:%02d" % (hours, minutes, seconly)
    else:
	nicetime = "%d:%02d" % (minutes, seconly)
    sys.stdout.write("%s: %.2f sec (%s)\n" % (name, duration, nicetime))

def dofile(name):
    f = open(name, "r")

    try:
	# See if it's an ASF container (usually .WMV).
	header = f.read(16)
	if header == "\x30\x26\xB2\x75\x8E\x66\xCF\x11\xA6\xD9\x00\xAA\x00\x62\xCE\x6C":
	    try:
		hdrlen = f.read(8)
		assert len(hdrlen) == 8
		hdrlen = decode_leu(hdrlen) - 30
		nhdrs = f.read(4)
		assert len(nhdrs) == 4
		nhdrs = decode_leu(nhdrs)
		f.read(2) # skip unknown field

		while nhdrs > 0:
		    ckhdr = f.read(16)
		    cklen = f.read(8)
		    assert len(ckhdr) == 16 and len(cklen) == 8
		    cklen = decode_leu(cklen)
		    assert hdrlen >= cklen
		    hdrlen = hdrlen - cklen
		    nhdrs = nhdrs - 1
		    ckdata = f.read(cklen - 24)
		    assert len(ckdata) == cklen - 24
		    if ckhdr == "\xA1\xDC\xAB\x8C\x47\xA9\xCF\x11\x8E\xE4\x00\xC0\x0C\x20\x53\x65":
			# found main header chunk
			assert len(ckdata) >= 56
			duration = decode_leu(ckdata[48:56])
			# ASF duration is measured in 100ns intervals
			duration = duration / 10000000.0
			printduration(name, duration)
			return
		
	    except AssertionError, x:
		# Any failure to parse means this file is corrupt.
		sys.stderr.write("%s: ASF container format appears corrupt\n" % name)
		pass
	else:
	    f.seek(0) # rewind

	# See if it's an AVI (RIFF structure).
	header = f.read(4)
	f.seek(4,1)
	filetype = f.read(4)
	if header == "RIFF" and filetype == "AVI ":
	    try:
		listhdr = f.read(4)
		assert listhdr == "LIST"
		f.seek(4,1)
		listtype = f.read(4)
		assert listtype == "hdrl"
		avih = f.read(4)
		assert avih == "avih"
		avihlen = f.read(4)
		assert len(avihlen) == 4
		avihlen = decode_leu(avihlen)
		assert avihlen >= 20
		avihdata = f.read(avihlen)
		assert len(avihdata) == avihlen
		usecperframe = decode_leu(avihdata[0:4])
		totalframes = decode_leu(avihdata[16:20])
		duration = (usecperframe * totalframes) / 1000000.0
		printduration(name, duration)
		return
	    except AssertionError, x:
		# Any failure to parse means this file is corrupt.
		sys.stderr.write("%s: AVI container format appears corrupt\n" % name)
		pass
	else:
	    f.seek(0) # rewind

	# See if it's a MOV (QuickTime).
	#
	# MOVs have no particularly clear magic number, so we
	# cannot separate identification of a file as MOV from
	# checking of its correctness. There is no third category
	# of `definitely a MOV but one we can't understand': either
	# a file parses successfully as a MOV, or it doesn't.
	try:
	    while 1:
		cklen = f.read(4)
		ckid = f.read(4)
		assert len(cklen) == 4 and len(ckid) == 4
		cklen = decode_beu(cklen)
		if ckid == "moov":
		    ckdata = f.read(cklen-8)
		    assert len(ckdata) == cklen-8
		    # See if we have a compressed moov atom.
		    if ckdata[4:8] == "cmov":
			assert ckdata[16:20] == "zlib"
			assert ckdata[24:28] == "cmvd"
			cmplen = decode_beu(ckdata[20:24]) - 12
			cmpdata = ckdata[32:32+cmplen]
			assert len(cmpdata) == cmplen
			ckdata = zlib.decompress(cmpdata)
			if ckdata[4:8] == "moov":
			    ckdata = ckdata[8:8+decode_beu(ckdata[:4])]
		    # Now we have an uncompressed moov atom. Go
		    # through it looking for the mvhd subatom.
		    ptr = 0
		    while ptr < len(ckdata):
			alen = decode_beu(ckdata[ptr:ptr+4])
			atyp = ckdata[ptr+4:ptr+8]
			if atyp == "mvhd":
			    adat = ckdata[ptr+8:ptr+alen]
			    assert len(adat) > 20
			    timescale = decode_beu(adat[12:16])
			    duration = decode_beu(adat[16:20])
			    printduration(name, float(duration) / timescale)
			    return
			ptr = ptr + alen
		else:
		    # skip this chunk and go on to the next
		    f.seek(cklen-8, 1)
	except AssertionError, x:
	    # it wasn't a MOV.
	    f.seek(0)

	# MPEG-1 `system multiplex' streams are completely barking
	# mad and nothing like any of the above basically IFF-like
	# formats. We can expect to find a number of things in an
	# MPEG-1 system stream, as follows...
	#  - A `pack header': 00 00 01 BA followed by eight bytes.
	#    A `pack' contains an optional system header and then
	#    one or more packets.
	#  - A system header: 00 00 01 BB, followed by eight bytes,
	#    followed by optionally a set of 3-byte stream IDs
	#    which start with a high-bit-set byte (and thus don't
	#    look like 00 00 01 so we can reliably tell them from
	#    the next actually interesting thing).
	#  - A packet: 00 00 01 (BC+streamid), followed by a
	#    two-byte packet length and then that many bytes (the
	#    packet length does not include those initial six
	#    bytes).
	#  - An end code, at the very EOF: 00 00 01 B9.
	#
	# Pack headers contain timestamps.
	#  - The first _five_ bytes of the pack header contain a
	#    33-bit integer timestamp called the SCR (system clock
	#    reference), encoded in a completely stupid subset of
	#    its bits: nnnnYYYn YYYYYYYY YYYYYYYn YYYYYYYY
	#    YYYYYYYn. (Big-endian.)
	#  - The remaining three bytes of the pack header contain a
	#    `mux rate', stored as nYYYYYYY YYYYYYYY YYYYYYYn
	#    (arrgh!), but as closely as I can tell that doesn't
	#    seem to be important right now.
	#  - I can't find it anywhere in the MPEG reference
	#    implementation, but the mplayer source code suggests
	#    that the unit of time is 1/90000 second (!!!).
	#
	# But packets _also_ contain timestamps, and those are
	# better ones because they indicate when the data is
	# supposed to be _displayed_ rather than when it gets read
	# from the disk. Unless, that is, the packet doesn't happen
	# to contain one, which is perfectly possible (arrgh). So.
	# After the packet length field, next in the packet we
	# find:
	#  - some optional 0xFF `stuffing' bytes
	#  - an optional `scale' specifier (a byte in [40-7F]
	#    followed by another byte)
	#  - either an optional PTS single timestamp (a byte in
	#    [20-2F] followed by four more bytes), or an optional
	#    PTS and DTS double timestamp ([30-3F] followed by nine
	#    more bytes).
	#
	# I think all we can sensibly do with an MPEG stream is go
	# all the way through it and pick out the highest timestamp
	# we can find from any of the pack or packet headers. This
	# isn't perfectly accurate (the last timestamp appears to
	# be that of the _start_ of the last packet or pack, which
	# means actual playback continues for a few frames after
	# that time), but it's the best I can do without trying to
	# untangle the video format as well as the system
	# multiplex. Good grief.
	try:
	    latesttime = 0
	    while 1:
		hdr = f.read(4)
		if hdr == "" or hdr == "\x00\x00\x01\xB9":
		    # end of file; output our best shot at the
		    # duration
		    printduration(name, latesttime / 90000.0)
		    return
		elif hdr == "\x00\x00\x01\xBA":
		    # pack header including an SCR timestamp
		    packhdr = f.read(8)
		    assert len(packhdr) == 8
		    latesttime = max(latesttime, mpegtimestamp(packhdr[:5]))
		elif hdr == "\x00\x00\x01\xBB":
		    # system header; skip it
		    syshdr = f.read(8)
		    while 1:
			streamid = f.read(3)
			assert len(streamid) == 3
			if ord(streamid[0]) < 0x80:
			    f.seek(-3,1)
			    break
		elif hdr[:3] == "\x00\x00\x01":
		    # actual packet; see if it contains a PTS
		    # and/or DTS timestamp
		    packetlen = f.read(2)
		    assert len(packetlen) == 2
		    packetlen = decode_beu(packetlen)
		    packetdata = f.read(packetlen)
		    assert len(packetdata) == packetlen
		    i = 0
		    while packetdata[i:i+1] == "\xFF":
			i = i + 1
		    if ord(packetdata[i:i+1]) >= 0x40 and ord(packetdata[i:i+1]) < 0x80:
			i = i + 2 # scale data
		    if ord(packetdata[i:i+1]) >= 0x20 and ord(packetdata[i:i+1]) < 0x30:
			# PTS only
			latesttime = max(latesttime, mpegtimestamp(packetdata[i:i+5]))
		    elif ord(packetdata[i:i+1]) >= 0x30 and ord(packetdata[i:i+1]) < 0x40:
			# PTS and DTS
			latesttime = max(latesttime, mpegtimestamp(packetdata[i:i+5]))
			latesttime = max(latesttime, mpegtimestamp(packetdata[i+5:i+10]))

	except AssertionError, x:
	    # it wasn't a valid MPEG stream. I think.
	    f.seek(0)

	# We've run through all the container formats we know.
	sys.stderr.write("%s: unknown movie file type\n" % name)
    finally:
	f.close()

args = sys.argv[1:]
opts = 1
for arg in args:
    if opts and arg[0] == "-":
	if arg == "--":
	    opts = 0
	elif arg == "-v":
	    verbose = 1
	else:
	    sys.stderr.write("unrecognised option '%s'\n" % arg)
	    sys.exit(1)
    else:
	dofile(arg)
